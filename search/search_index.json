{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentaci\u00f3n del Proyecto","text":"<p>Bienvenido \ud83d\udc4b Esta es una plantilla basada en MkDocs + Material for MkDocs para cursos y proyectos.</p>"},{"location":"#empezar-rapido-3-pasos","title":"Empezar r\u00e1pido (3 pasos)","text":"<ol> <li>Edita el nombre del sitio en <code>mkdocs.yml</code>:    ```yaml    site_name: Documentaci\u00f3n del Curso    theme:      name: material</li> </ol>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"Proyecto_de_ingenieria%204/Intro/","title":"Introduccion","text":"<p>Hola, mi nombre es Carlos Guti\u00e9rrez Mart\u00ednez, tengo 19 a\u00f1os y soy estudiante en la Universidad Iberoamericana de Puebla, estudio la carrera de Ingenier\u00eda en Mecatr\u00f3nica y estoy cursando mi quinto semestre.En este apartado estar\u00e9 subiendo el progreso hecho durante mis clases de Proyectos de Ingenier\u00eda 4.</p>"},{"location":"Proyecto_de_ingenieria%204/Intro/#propuesta-proyecto","title":"Propuesta proyecto","text":"<p>La propuesta de mi proyecto a desarrollar este semestre consiste en un dispositivo capaz de medir la intensidad de los rayos UV del entorno en el que se encuentre y con base a eso poder realizar un diagn\u00f3stico de los cuidados necesarios para evitar da\u00f1os en la piel, el producto est\u00e1 centrado principalmente en evitar da\u00f1os o enfermedades potenciales a aquellas personas que cuentan con un tipo de piel sensible, al mismo tiempo busca poder funcionar como un producto que permita mantener un mejor cuidad de piel.</p>"},{"location":"Proyecto_de_ingenieria%204/Intro/#boceto-inicial","title":"Boceto inicial","text":""},{"location":"Proyecto_de_ingenieria%204/Intro/#caracteristicas-que-debe-de-tener-el-producto","title":"Caracteristicas que debe de tener el producto","text":"<ul> <li>Debe de ser capaz de transformar la intensidad de los rayos UV en valores num\u00e9ricos.</li> <li>Tiene que ser capaz de generar una predicci\u00f3n en relaci\u00f3n al tiempo que tardar\u00eda la piel en recibir da\u00f1os.</li> <li>Tiene que tener los datos de los tipos de piel y como la variable de los rayos UV afecta de forma distinta a cada tipo de piel.</li> </ul>"},{"location":"Proyecto_de_ingenieria%204/Semana1/","title":"Semana 1","text":""},{"location":"Proyecto_de_ingenieria%204/Semana1/#nivel-de-madureza-tecnologica-tlr","title":"Nivel de Madureza Tecnol\u00f3gica (TLR)","text":"<p>\u00bfQu\u00e9 es el nivel de Madureza Tecnol\u00f3gica? </p> <p>Es una medida para describir el estado de desarrollo o madurez de una tecnolog\u00eda.</p> <p>No s\u00f3lo se aplica para medir el estado de madurez de una tecnolog\u00eda para su uso en el entorno operativo, sino que tambi\u00e9n se interpreta como la preparaci\u00f3n de un producto o servicio para ser comercializado.</p> <p>Existen 9 distintos niveles de madurez tecnol\u00f3gica.</p> <p>\u00bfPorque es relevante el Nivel de Madurez Tecnol\u00f3gica para este proyecto? </p> <p>Este semestre el objetivo que mi equipo tiene planeado es poder conseguir llevar un proyecto nuevo a TLR4, por lo que para poder lograrlo se tienen que cumplir los siguientes requisitos:</p> <p>-Prototipo a nivel banco de laboratorio, en donde se pueda medir con alg\u00fan grado de seguridad, que dicho prototipo puede ser escalable cuyas ventajas competitivas y comparativas pueden ser medibles.</p> <p>-Los componentes han sido identificados y se busca establecer si dichos componentes cuentan con las capacidades para actuar de manera conjunta.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana1/#syllabus-firmado","title":"Syllabus Firmado","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyecto_de_ingenieria%204/Semana2/","title":"Semana 2","text":"<p>Esta presentaci\u00f3n sobre la evoluci\u00f3n del caf\u00e9 hasta las m\u00e1quinas de c\u00e1psulas, con un enfoque en Nespresso como l\u00edder del mercado.     Analizar c\u00f3mo Nespresso desarroll\u00f3 su tecnolog\u00eda, optimiz\u00f3 sus m\u00e1quinas y estandariz\u00f3 sus c\u00e1psulas nos permite entender c\u00f3mo se aplican conceptos de dise\u00f1o mecatr\u00f3nico, sensores, actuadores y control de procesos en un producto real. Adem\u00e1s, sirve como inspiraci\u00f3n para la creaci\u00f3n de nuestro propio proyecto, mostrando la importancia de llevar un prototipo desde la investigaci\u00f3n y pruebas hasta un sistema confiable y listo para el usuario, aplicando estrategias de innovaci\u00f3n y validaci\u00f3n tecnol\u00f3gica.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana2/#nesspreso","title":"NESSPRESO","text":"<p>\u00bfQu\u00e9 diferencia a NESPRESSO del resto?</p>"},{"location":"Proyecto_de_ingenieria%204/Semana2/#propuestas-a-evaluar-y-las-problematicas-que-resuelven","title":"Propuestas a evaluar y las problematicas que resuelven","text":"<p>A partir del an\u00e1lisis a la compa\u00f1\u00eda NESPRESSO, el equipo realiz\u00f3 un an\u00e1lisis similar para evaluar las propuestas de mi propio proyecto, aplicando los mismos criterios: identificar los requerimientos tecnol\u00f3gicos, dise\u00f1ar prototipos funcionales y validar su desempe\u00f1o. Propuestas finales</p>"},{"location":"Proyecto_de_ingenieria%204/Semana3/","title":"Semana 3","text":"<p>Esta semana elabromas un diagrama de gantt para poder visualizar de manera organizada las tareas que debemos realizar para poder concretar el proyecto, y designar un periodo espec\u00edfico de tiempo a cada tarea, todo con el prop\u00f3sito de agilizar la elaboraci\u00f3n del producto final.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana3/#que-es-un-diagrama-de-gantt","title":"\u00bfQu\u00e9 es un diagrama de Gantt?","text":"<p>Un diagrama de Gantt es en resumidas cuentas un gr\u00e1fico de barras horizontales que muestran la duraci\u00f3n, las fechas de inicio y fin, el progreso y las dependencias entre las tareas; ayuda mucho a la hora de agilizar y organizar proyectos de forma clara.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana3/#diagrama-de-gantt-del-proyecto","title":"Diagrama de Gantt del proyecto","text":"<p>Para el diagrama de Gantt nuestro equipo utiliz\u00f3 una plataforma llamada JIRA, la cual est\u00e1 especializada en diagramas para proyectos, la plataforma es sumamente sencilla de usar y permite asignar fechas, delegar tareas o actividades a diferentes miembros de equipo, y asignar un nivel de prioridad a cada tarea.</p> <ul> <li>Paso 1: A\u00f1adimos las tareas u objetivos principales, aquellos que son esenciales que cumplamos para poder terminar un producto exitoso.</li> </ul> <p></p> <ul> <li>Paso 2: Colocamos sub-objetivos que permitan monitorear de forma m\u00e1s espec\u00edfica los avances requeridos, de esta forma se puede dividir el trabajo de forma m\u00e1s eficiente.</li> </ul> <p></p> <ul> <li>Paso 3: Teniendo todo lo anterior solo nos movemos a la barra de nombre \"cronograma\" y podemos visualizar nuestro diagrama de Gantt ya finalizado, el cual ayudar\u00e1 a poder organizar nuestras tareas de forma limpia.</li> </ul> <p></p> <p>Enlace para visualizar el diagrama de Gantt</p>"},{"location":"Proyecto_de_ingenieria%204/Semana4/","title":"Semana 4","text":""},{"location":"Proyecto_de_ingenieria%204/Semana4/#que-es-un-marco-real-ganar-vale-la-pena","title":"\u00bfQu\u00e9 es un marco \"Real-Ganar-Vale la pena\"","text":"<p>Un Marco \"real-ganar-vale la pena\" (Real-Win-Worth it o RGW) es una herramienta de evaluaci\u00f3n desarrollada por 3M para analizar la viabilidad de una idea o producto en tres frentes: que sea real, que se pueda ganar y que valga la pena. Este m\u00e9todo ayuda a las empresas a filtrar y seleccionar las ideas m\u00e1s prometedoras para el desarrollo, asegurando que la idea sea viable en el mercado y que pueda generar beneficios. </p>"},{"location":"Proyecto_de_ingenieria%204/Semana4/#que-criterios-evalua","title":"\u00bfQu\u00e9 criterios eval\u00faa?","text":"<ol> <li> <p>Real (\u00bfEs Real?): Se eval\u00faa la viabilidad t\u00e9cnica y de mercado del producto. La pregunta clave es si la tecnolog\u00eda existe o puede desarrollarse y si el producto tiene demanda en el mercado.</p> </li> <li> <p>Ganar (\u00bfSe Puede Ganar?): Se analiza la capacidad de la empresa para competir y tener \u00e9xito en el mercado. Esto implica considerar la posici\u00f3n de la empresa, sus recursos y la competencia.</p> </li> <li> <p>Vale la pena (\u00bfVale la pena?): Se determina si la inversi\u00f3n en el producto es rentable y justificar\u00e1 el esfuerzo. La empresa debe considerar los beneficios esperados frente a los costos y riesgos asociados.</p> </li> </ol> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyecto_de_ingenieria%204/Semana5/","title":"Semana 5","text":""},{"location":"Proyecto_de_ingenieria%204/Semana5/#objetivo","title":"Objetivo","text":"<ul> <li>Definir qui\u00e9n es el cliente de tu proyecto y el tama\u00f1o de ese mercado.</li> <li>Realizar el an\u00e1lisis de las 5 fuerzas de Porter.</li> <li>Hacer la propuesta de valor de su proyecto con la tabla Creando Valor.</li> </ul> <p>Definir qui\u00e9n es el cliente de un proyecto y conocer el tama\u00f1o de su mercado es fundamental porque permite orientar los esfuerzos de dise\u00f1o, producci\u00f3n y comunicaci\u00f3n hacia las personas que realmente necesitan y valoran la soluci\u00f3n. Si se identifica claramente al cliente, se pueden entender mejor sus necesidades, problemas y motivaciones, lo que facilita crear un producto o servicio m\u00e1s relevante y competitivo. Al mismo tiempo, estimar el tama\u00f1o del mercado ayuda a dimensionar la oportunidad: permite saber si existe una demanda suficiente que justifique la inversi\u00f3n, planear estrategias de crecimiento y anticipar la viabilidad econ\u00f3mica del proyecto. En conjunto, estos elementos son la base para que el proyecto tenga un impacto real y sostenible.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana5/#analisis-de-mercado","title":"An\u00e1lisis de mercado","text":"<p>El an\u00e1lisis de mercado es importante porque permite entender las necesidades, preferencias y comportamientos de los posibles usuarios, as\u00ed como identificar la competencia y las oportunidades existentes. Gracias a este estudio, podemos definir mejor el p\u00fablico objetivo, ajustar el dise\u00f1o y precio del producto y tomar decisiones m\u00e1s acertadas que aumenten las posibilidades de \u00e9xito y aceptaci\u00f3n del proyecto en el mercado real.</p> <p>An\u00e1lisis de mercado</p>"},{"location":"Proyecto_de_ingenieria%204/Semana5/#cuadro-de-valor","title":"Cuadro de Valor","text":"<p>El cuadro de valor  es fundamental porque permite comparar nuestro producto con las alternativas existentes, destacando los aspectos que lo hacen \u00fanico o m\u00e1s beneficioso para el usuario. A trav\u00e9s de este an\u00e1lisis, podemos identificar fortalezas, debilidades y oportunidades de mejora, adem\u00e1s de comunicar con claridad el valor que aporta nuestro proyecto, tanto en funcionalidad como en costo y accesibilidad.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana5/#analisis-de-las-5-fuerzas-de-porter","title":"An\u00e1lisis de las 5 fuerzas de Porter","text":"<p>El an\u00e1lisis de las 5 fuerzas de Porter es una herramienta estrat\u00e9gica que sirve para evaluar la competitividad de una industria o sector. Fue desarrollada por Michael Porter y busca entender qu\u00e9 tan atractivo o rentable puede ser un mercado, analizando los factores externos que influyen en \u00e9l.</p> <p>Las cinco fuerzas son:</p> <ul> <li> <p>Rivalidad entre competidores existentes: mide el nivel de competencia directa en el mercado (n\u00famero de competidores, precios, diferenciaci\u00f3n de productos).</p> </li> <li> <p>Amenaza de nuevos entrantes: eval\u00faa qu\u00e9 tan f\u00e1cil o dif\u00edcil es para nuevas empresas entrar en la industria y competir.</p> </li> <li> <p>Poder de negociaci\u00f3n de los proveedores: analiza la influencia que tienen los proveedores sobre los costos y la disponibilidad de insumos.</p> </li> <li> <p>Poder de negociaci\u00f3n de los clientes: examina qu\u00e9 tanto poder tienen los consumidores para exigir precios bajos, mayor calidad o mejores condiciones.</p> </li> <li> <p>Amenaza de productos sustitutos: identifica si existen alternativas que puedan reemplazar la soluci\u00f3n que ofrece el producto o servicio.</p> </li> </ul>"},{"location":"Proyecto_de_ingenieria%204/Semana6/","title":"Semana 6","text":""},{"location":"Proyecto_de_ingenieria%204/Semana6/#tarjetas-de-trabajo","title":"Tarjetas de trabajo","text":"<p>Esta semana creamos un \u00e1rea de trabajo personalizable, para poder asignar trabajos, tareas, objetivos y recursos de manera organizada en un espacion online compartido con todo el equipo.</p> <p>Para esto utilizamos la aplicaci\u00f3n TRELLO, la cual nos permite hacer todo lo anterior de forma sencillas y simple.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana6/#ventajas-al-usar-trello","title":"Ventajas al usar TRELLO","text":"<ol> <li> <p>Visualizar el progreso:Las tarjetas se mueven entre columnas tipo \u201cPor hacer \u2192 En proceso \u2192 Hecho\u201d, lo que te permite ver el avance del proyecto de un vistazo.Es muy \u00fatil para detectar bloqueos (por ejemplo, tareas que llevan demasiado tiempo en \u201cEn proceso\u201d).</p> </li> <li> <p>Gesti\u00f3n de tiempo y prioridades:Puedes poner fechas l\u00edmite o etiquetas (\u201cAlta prioridad\u201d, \u201cInvestigaci\u00f3n\u201d, \u201cDise\u00f1o\u201d) y as\u00ed concentrarte en lo m\u00e1s urgente o importante.</p> </li> <li> <p>Documentaci\u00f3n del proyecto: Cada tarjeta puede tener notas, enlaces, im\u00e1genes o archivos, as\u00ed que sirve como registro del trabajo.Esto es muy \u00fatil cuando tienes que presentar el proyecto o explicar c\u00f3mo fue evolucionando.</p> </li> </ol>"},{"location":"Proyecto_de_ingenieria%204/Semana6/#costos-de-produccion-costos-de-materiales","title":"Costos de producci\u00f3n (costos de materiales)","text":""},{"location":"Proyecto_de_ingenieria%204/Semana6/#importancia-de-minimizar-costos","title":"Importancia de minimizar costos","text":"<p>Para poder crear el prototipo necesitamos varios materiales, por lo mismo es imperativo encontrar los mejores precios que permitan mantener un costo de producci\u00f3n m\u00ednimo, ayudando as\u00ed tambi\u00e9n a impulsar las ganancias del producto.Debido a lo mencionado nosotros investigamos en diferentes sitios web, desde empresas grandes (Mercado libre, Amazon) a locales peque\u00f1os  (tiendas de electronica locales) para poder encontrar los mejores materiales por el mejor precio, a continuaci\u00f3n incluyo la evidencia de dicha investigaci\u00f3n.</p> <p>Investigaci\u00f3n de costos de arranque.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana6/#ciclos-intentos","title":"Ciclos (intentos)","text":"<p>En la presentaci\u00f3n anterior mencionamos algo llamado \"ciclo\", para aquellos que no entiendan a que se refiere esto, un ciclo es el equivalente a un intento, refieri\u00e9ndonos claro a la elaboraci\u00f3n de alguna parte del prototipo, por lo que ciclo se refiere a cuantos intentos se requiere para poder alcanzar el objetivo deseado.Esta terminolog\u00eda nos permite hacer un an\u00e1lisis realista de cuanto tiempo, esfuerzo o personal requiere cada fase del proyecto, lo que permite distribuir recursos y tiempo de forma m\u00e1s eficiente.</p> <p>Al hacer una an\u00e1lisis de ciclos, el conocimiento emp\u00edrico es sumamente relevante, ya que muchas veces la planeaci\u00f3n y teor\u00eda son mucho m\u00e1s f\u00e1ciles que la pr\u00e1ctica.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana7/","title":"Semana 7","text":"<p>Hicimos una tabla de costos para nuestro prototipo con el objetivo de tener una visi\u00f3n clara y organizada de los recursos necesarios para su desarrollo desde cero. En ella se desglosan tanto los costos de producci\u00f3n \u2014como materiales, componentes electr\u00f3nicos, herramientas y mano de obra\u2014, como los costos de distribuci\u00f3n que se planean adoptar, incluyendo empaque, transporte y posibles canales de venta. Esta tabla nos permite estimar el presupuesto total, evaluar la viabilidad econ\u00f3mica del proyecto y planificar una estrategia de producci\u00f3n sostenible, asegurando que el prototipo no solo sea funcional, sino tambi\u00e9n accesible y realista para su futura implementaci\u00f3n o comercializaci\u00f3n.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana7/#creando-la-oferta","title":"Creando la oferta","text":"<p>Al crear la oferta de nuestro producto, es necesario dividir los costos individuales que se requieren para la producci\u00f3n unitaria de dicha prototipo, de manera que se pueda crear un an\u00e1lisis en relaci\u00f3n a un a\u00f1o (nosotros elegimos un a\u00f1o) de cu\u00e1nto costar\u00eda la producci\u00f3n de una cantidad determinada del producto terminado.</p> <p>En este caso, nosotros separamos nuestros costos de manera que se pueda identificar, cu\u00e1les son aquellos que diferencian a nuestro producto de los dem\u00e1s.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana7/#dsitribucion-del-producto","title":"Dsitribuci\u00f3n del producto","text":"<p>La distribuci\u00f3n del producto es ESENCIAL para la creaci\u00f3n y venta de una idea, ya que se tiene que considerar \u00bfa qui\u00e9n? y \u00bfc\u00f3mo? vas a hacer llegar tu idea.</p> <p>A continuaci\u00f3n adjunto nuestro excel.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana8/","title":"Semana 8","text":""},{"location":"Proyecto_de_ingenieria%204/Semana8/#evaluacion-de-conocimiento-viablidad-factibilidad-y-pertinencia","title":"Evaluaci\u00f3n de conocimiento : Viablidad, Factibilidad y Pertinencia","text":"<p>Durante este clase se nos pidi\u00f3 determinar el Valor Futur (VF), Valor presente (VP), Valor Presente Neto (VPN), y el TIR, de diferentes empresas, con el proposito de poder practicat estos c\u00e1lculos, que en muchas empresas determina si es viable invertir en el proyecto o no.</p> <p>A continuaci\u00f3n adjunto el excel con los ejercicios realizados durante esta clase:Descargar EXCEL</p> <ol> <li>Valor Presente Neto (VPN o NPV)</li> </ol> <p>El VPN indica si un proyecto genera m\u00e1s dinero del que cuesta, considerando el valor del dinero en el tiempo.</p> <p>\u00bfPor qu\u00e9 es importante?</p> <ul> <li> <p>Determina si un proyecto crea o destruye valor.</p> </li> <li> <p>Permite comparar diferentes inversiones bajo el mismo criterio.</p> </li> <li> <p>Ayuda a priorizar proyectos cuando el capital es limitado.</p> </li> <li> <p>Si el VPN es positivo, el proyecto es rentable; si es negativo, no conviene.</p> </li> <li> <p>Tasa Interna de Retorno (TIR)</p> </li> </ul> <p>La TIR es la tasa de rendimiento que produce un proyecto. Representa la tasa de inter\u00e9s equivalente del dinero invertido.</p> <p>\u00bfPor qu\u00e9 es importante?</p> <ul> <li> <p>Indica el porcentaje real de ganancia sobre la inversi\u00f3n.</p> </li> <li> <p>Permite comparar proyectos con diferentes tama\u00f1os, duraciones o costos.</p> </li> <li> <p>Facilita decidir si la inversi\u00f3n es mejor que otras alternativas (por ejemplo, CETES, bonos, maquinaria, ampliaciones, etc.).</p> </li> <li> <p>Si la TIR es mayor que el costo de capital de la empresa, el proyecto conviene.</p> </li> <li> <p>Valor Presente (VP)</p> </li> </ul> <p>El VP convierte flujos futuros en su valor actual, permitiendo saber cu\u00e1nto valen realmente ganancias o costos que ocurrir\u00e1n en el futuro.</p> <p>\u00bfPor qu\u00e9 es importante?</p> <ul> <li> <p>Permite tomar decisiones realistas en escenarios donde el dinero cambia de valor.</p> </li> <li> <p>Ayuda a comparar flujos de dinero que ocurren en diferentes momentos.</p> </li> <li> <p>Evita sobreestimar beneficios futuros.</p> </li> <li> <p>Con VP sabes cu\u00e1nto \u201cvalen hoy\u201d los ingresos futuros de un proyecto.</p> </li> <li> <p>Valor Futuro (VF)</p> </li> </ul> <p>El VF proyecta cu\u00e1nto valdr\u00e1 una inversi\u00f3n en el futuro considerando una tasa de crecimiento o inter\u00e9s.</p> <p>\u00bfPor qu\u00e9 es importante?</p> <ul> <li> <p>Permite planear metas financieras a largo plazo.</p> </li> <li> <p>Ayuda a calcular cu\u00e1nto crecer\u00e1n los recursos invertidos.</p> </li> <li> <p>Facilita analizar estrategias de reinversi\u00f3n o acumulaci\u00f3n.</p> </li> <li> <p>Se usa para saber si un proyecto ayuda a cumplir metas de crecimiento financiero.</p> </li> </ul>"},{"location":"Proyecto_de_ingenieria%204/Semana9/","title":"Semana 9","text":""},{"location":"Proyecto_de_ingenieria%204/Semana9/#investigacion-de-patentes","title":"Investigaci\u00f3n de patentes","text":"<p>Una patente es un derecho exclusivo otorgado por el Estado a un inventor para explotar una invenci\u00f3n durante un tiempo limitado, normalmente 20 a\u00f1os a partir de la fecha de solicitud.</p> <p>Una patente protege una invenci\u00f3n t\u00e9cnica (producto, proceso o mejora) y le da al inventor el derecho de impedir que otros fabriquen, utilicen, vendan o importen esa invenci\u00f3n sin permiso.</p> <p>## \u00bfQu\u00e9 son y por qu\u00e9 son tan importantes?</p> <p>Evitar infringir patentes:</p> <p>Si tu producto utiliza un m\u00e9todo, dise\u00f1o o tecnolog\u00eda ya patentada por otra empresa, puedes incurrir en infracci\u00f3n. Esto puede generar:</p> <ul> <li> <p>Demandas legales costosas</p> </li> <li> <p>Prohibici\u00f3n de vender tu producto</p> </li> <li> <p>Pago de regal\u00edas obligatorias</p> </li> <li> <p>P\u00e9rdidas econ\u00f3micas y de reputaci\u00f3n</p> </li> <li> <p>La investigaci\u00f3n de patentes te permite saber qu\u00e9 no puedes copiar y qu\u00e9 tecnolog\u00edas est\u00e1n protegidas.</p> </li> </ul> <p>Detectar oportunidades para patentar algo nuevo:</p> <p>Analizar el panorama de patentes te ayuda a saber si:</p> <ul> <li> <p>Lo que desarrollaste es novedoso</p> </li> <li> <p>Tienes elementos patentables</p> </li> <li> <p>Puedes registrar tu propia patente para protegerte</p> </li> </ul> <p>Adem\u00e1s, una patente bien hecha te da ventaja competitiva en el mercado. En conclusi\u00f3n investigar patentes es importante porque reduce riesgos, protege tu innovaci\u00f3n, te da ventaja competitiva y asegura que puedes comercializar tu producto con seguridad jur\u00eddica.</p>"},{"location":"Proyecto_de_ingenieria%204/PROYECTO_FINAL/Proyecto_final/","title":"Proyecto final (Sensor de Rayos UV)","text":""},{"location":"Proyecto_de_ingenieria%204/PROYECTO_FINAL/Proyecto_final/#documentacion","title":"Documentacion","text":"<p>https://docs.google.com/document/d/1Aq8cDvQNRT79WB4VP8NVQ41ni2gByOhUjRWilLIoYI8/edit?usp=sharing</p>"},{"location":"Proyecto_de_ingenieria%204/PROYECTO_FINAL/Proyecto_final/#presentacion","title":"Presentaci\u00f3n","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyecto_de_ingenieria%204/PROYECTO_FINAL/Proyecto_final/#analisis-de-costos-y-produccion","title":"An\u00e1lisis de costos y producci\u00f3n","text":"<p>Descargar EXCEL</p>"},{"location":"Proyecto_de_ingenieria%204/PROYECTO_FINAL/Semana10/","title":"Proyecto- \"costos\"","text":""},{"location":"Proyecto_de_ingenieria%204/PROYECTO_FINAL/Semana10/#buisness-case","title":"Buisness Case","text":"<p>Durante esta semana, mi equipo decidi\u00f3 concentrarse en la elaboraci\u00f3n de la tabla de costos de producci\u00f3n y venta con el objetivo de obtener una visi\u00f3n financiera integral del proyecto. Este an\u00e1lisis nos permiti\u00f3 estimar el comportamiento de las ventas a cinco a\u00f1os, calcular el periodo de recuperaci\u00f3n de la inversi\u00f3n y proyectar las utilidades esperadas. Con ello buscamos construir un escenario s\u00f3lido que respalde la viabilidad econ\u00f3mica del producto y oriente las decisiones estrat\u00e9gicas en las siguientes etapas del desarrollo.</p> <p>A continuaci\u00f3n incluyo el excel en el cual se trabajo lo mencionado previamente:Descargar EXCEL</p>"},{"location":"Proyecto_de_ingenieria%204/PROYECTO_FINAL/Semana10/#resumen","title":"Res\u00famen","text":"<p>Para la elaboraci\u00f3n de este documento se tuvieron en cuenta varios aspectos en el an\u00e1lisis de venta del producto:</p> <ul> <li>ISR de 30%</li> <li>IVA sobre el producto de 16%</li> <li>Inflaci\u00f3n de costos de 10%</li> </ul>"},{"location":"Proyecto_de_ingenieria%204/PROYECTO_FINAL/Semana10/#factores-a-tomar-en-cuenta","title":"Factores a tomar en cuenta","text":"<ul> <li> <p>Para este documento se investigo el precio al mayoreo de los componentes que constitutyen el producto, por lo que al ser de por s\u00ed un proyecto de bajo costo se logr\u00f3 reducir todav\u00eda m\u00e1s el gasto de producci\u00f3n.</p> </li> <li> <p>En el documento se puedes visualizar que en el primer a\u00f1o no hay retorno de inversiones tanto para los inversionistas como para los socios fundadores (el equipo), sin embargo esto es debido a que como socios e inversionistas nosotros no cobramos ganancias hasta la empresa genere ganancias suficientes, por lo que en el primer a\u00f1o se reinvierte lo ganado para aumentar la producci\u00f3n y poder de esta forma generar ganancia en el a\u00f1o 2.</p> </li> </ul> <p>Es importante recalcar esto ya que desde un punto de vista se podr\u00eda considerar como que en el primer a\u00f1o al equipo no se le paga, sin embargo el equipo no se considera como un empleado, sino como un socio due\u00f1o de una parte de la compa\u00f1\u00eda, por lo que es relevante priorizar el aumento de producci\u00f3n en el segundo a\u00f1o para llegar al objetivo planeado.</p> <ul> <li>Se hizo un an\u00e1lisis con una inversi\u00f3n de $300,000.00 en intercambio por 20% de la compa\u00f1\u00eda, esto con el objetivo de cubrir gastos, esta inversi\u00f3n permite al inversionista duplicar su inversi\u00f3n inicial para el a\u00f1o 5.</li> </ul>"},{"location":"Proyecto_de_ingenieria%204/PROYECTO_FINAL/Semana11/","title":"Proyecto - \"Pitch\"","text":""},{"location":"Proyecto_de_ingenieria%204/PROYECTO_FINAL/Semana11/#presentacion","title":"Presentaci\u00f3n","text":"<p>Esta semana, el equipo concentr\u00f3 sus esfuerzos en la elaboraci\u00f3n de la presentaci\u00f3n tipo pitch dirigida a convencer a los profesores-inversionistas dentro de la din\u00e1mica estilo Shark Tank. El trabajo se orient\u00f3 a estructurar un mensaje claro, s\u00f3lido y atractivo que comunicara el valor del proyecto, su propuesta de soluci\u00f3n, el potencial del mercado y la viabilidad t\u00e9cnica y financiera. Se dedic\u00f3 tiempo a depurar el argumento central, fortalecer la narrativa visual y preparar respuestas estrat\u00e9gicas para posibles preguntas, buscando transmitir seguridad, dominio del proyecto y una visi\u00f3n convincente que motive la inversi\u00f3n.</p> <p>Descargar la presentaci\u00f3n</p>"},{"location":"Proyecto_de_ingenieria%204/PROYECTO_FINAL/Semana12/","title":"Proyecto- \"Documentacion\"","text":"<p>https://docs.google.com/document/d/1Aq8cDvQNRT79WB4VP8NVQ41ni2gByOhUjRWilLIoYI8/edit?usp=sharing</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Primer_examen/","title":"Primer examen parcial","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Primer_examen/#objetivo","title":"Objetivo","text":"<p>Construir un juego Sim\u00f3n Dice de 4 colores en Raspberry Pi Pico 2.</p> <ul> <li>La secuencia crece +1 por ronda, de 1 hasta 15.</li> <li>La persona jugadora debe repetir la secuencia con 4 botones dentro de un tiempo l\u00edmite por ronda.</li> <li>Tiempo l\u00edmite por ronda (fase de entrada): TL = longitud + 5 segundos (p. ej., Ronda 7 \u2192 12 s).</li> <li>Puntaje (0\u201315): mostrar la m\u00e1xima ronda alcanzada en un display de 7 segmentos en hex (0\u20139, A, b, C, d, E, F).</li> <li>Aleatoriedad obligatoria: la secuencia debe ser impredecible en cada ejecuci\u00f3n.</li> </ul>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Primer_examen/#condiciones","title":"Condiciones","text":"<ol> <li>Encendido/Reset: el 7 segmentos muestra \u201c0\u201d y queda en espera de Start (cualquier bot\u00f3n permite iniciar).</li> <li>Reproducci\u00f3n:: mostrar la secuencia actual (LEDs uno por uno con separaci\u00f3n clara).</li> <li>Entrada: al terminar la reproducci\u00f3n, la persona debe repetir la secuencia completa dentro de TL.</li> <li>Fallo (Game Over): bot\u00f3n incorrecto, falta/extra de entradas o exceder TL.</li> <li>Progresi\u00f3n: si acierta, puntaje = n\u00famero de ronda, agrega 1 color aleatorio y avanza.</li> <li>Fin: al fallar o completar la Ronda 15. Mostrar puntaje final en 7 segmentos (hex).</li> </ol> <pre><code>#include \"pico/stdlib.h\" // Librer\u00eda b\u00e1sica de Raspberry Pi Pico (GPIO, sleep, etc.)\n#include &lt;stdlib.h&gt;      // Para rand() y srand()\n#include &lt;time.h&gt;        // Para obtener tiempo y usarlo como semilla aleatoria\n\n// --- Pines de LEDs y botones ---\nconst uint LED_PINS[4] = {0, 1, 2, 3};       // Pines GPIO donde est\u00e1n conectados los LEDs\nconst uint BUTTON_PINS[4] = {4, 5, 6, 7};    // Pines GPIO donde est\u00e1n conectados los botones\n\n// --- Pines de display de 7 segmentos (\u00e1nodo com\u00fan) ---\nconst uint SEG_PINS[7] = {13, 12, 18, 17, 16, 14, 15}; // Pines de segmentos a-g\n\n// --- Constantes de juego ---\n#define MAX_ROUNDS 15      // N\u00famero m\u00e1ximo de rondas\n#define LED_ON_TIME 400    // Tiempo en ms que un LED permanece encendido\n#define LED_OFF_TIME 200   // Tiempo en ms que un LED permanece apagado entre flashes\n\nint sequence[MAX_ROUNDS];  // Array donde se guarda la secuencia de LEDs de cada ronda\n\n// --- Segmentos por nombre para mayor claridad ---\n#define SEG_A 0\n#define SEG_B 1\n#define SEG_C 2\n#define SEG_D 3\n#define SEG_E 4\n#define SEG_F 5\n#define SEG_G 6\n\n// --- Definici\u00f3n de n\u00fameros seg\u00fan qu\u00e9 segmentos se encienden (0-F) ---\nconst uint8_t NUM_SEGMENTS[16][7] = {\n    {SEG_A, SEG_B, SEG_C, SEG_D, SEG_E, SEG_F, 255},   // 0\n    {SEG_B, SEG_C, 255, 255, 255, 255, 255},           // 1\n    {SEG_A, SEG_B, SEG_D, SEG_E, SEG_G, 255, 255},     // 2\n    {SEG_A, SEG_B, SEG_C, SEG_D, SEG_G, 255, 255},     // 3\n    {SEG_B, SEG_C, SEG_F, SEG_G, 255, 255, 255},       // 4\n    {SEG_A, SEG_C, SEG_D, SEG_F, SEG_G, 255, 255},     // 5\n    {SEG_A, SEG_C, SEG_D, SEG_E, SEG_F, SEG_G, 255},   // 6\n    {SEG_A, SEG_B, SEG_C, 255, 255, 255, 255},         // 7\n    {SEG_A, SEG_B, SEG_C, SEG_D, SEG_E, SEG_F, SEG_G}, // 8\n    {SEG_A, SEG_B, SEG_C, SEG_D, SEG_F, SEG_G, 255},   // 9\n    {SEG_A, SEG_B, SEG_C, SEG_E, SEG_F, SEG_G, 255},   // A\n    {SEG_C, SEG_D, SEG_E, SEG_F, SEG_G, 255, 255},     // B\n    {SEG_A, SEG_D, SEG_E, SEG_F, 255, 255, 255},       // C\n    {SEG_B, SEG_C, SEG_D, SEG_E, SEG_G, 255, 255},     // D\n    {SEG_A, SEG_D, SEG_E, SEG_F, SEG_G, 255, 255},     // E\n    {SEG_A, SEG_E, SEG_F, SEG_G, 255, 255, 255}        // F\n};\n\n// --- Inicializaci\u00f3n de hardware ---\nvoid init_hardware() {\n    // Configura LEDs y botones\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(LED_PINS[i]);           // Inicializa pin LED\n        gpio_set_dir(LED_PINS[i], true);  // Lo pone como salida\n        gpio_put(LED_PINS[i], 0);         // Lo apaga inicialmente\n\n        gpio_init(BUTTON_PINS[i]);        // Inicializa pin de bot\u00f3n\n        gpio_set_dir(BUTTON_PINS[i], false); // Lo pone como entrada\n        gpio_pull_up(BUTTON_PINS[i]);     // Activa pull-up interno para leer 1 cuando no se presiona\n    }\n\n    // Configura display de 7 segmentos\n    for (int i = 0; i &lt; 7; i++) {\n        gpio_init(SEG_PINS[i]);           // Inicializa pin de segmento\n        gpio_set_dir(SEG_PINS[i], true);  // Salida\n        gpio_put(SEG_PINS[i], 1);         // Apaga todos los segmentos inicialmente (\u00e1nodo com\u00fan)\n    }\n}\n\n// --- Enciende un LED por un tiempo y lo apaga ---\nvoid blink_led(int led_index) {\n    gpio_put(LED_PINS[led_index], 1);   // Enciende LED\n    sleep_ms(LED_ON_TIME);               // Espera tiempo definido\n    gpio_put(LED_PINS[led_index], 0);   // Apaga LED\n    sleep_ms(LED_OFF_TIME);              // Espera tiempo definido antes del siguiente LED\n}\n\n// --- Muestra un n\u00famero en el display de 7 segmentos ---\nvoid display_number_inverted(uint8_t num) {\n    if (num &gt; 15) return;                // Solo n\u00fameros 0-F\n    for (int i = 0; i &lt; 7; i++) gpio_put(SEG_PINS[i], 1); // Apaga todos los segmentos\n    for (int j = 0; j &lt; 7; j++) {\n        if (NUM_SEGMENTS[num][j] == 255) break;           // Fin de segmentos para ese n\u00famero\n        gpio_put(SEG_PINS[NUM_SEGMENTS[num][j]], 0);     // Enciende segmento correspondiente\n    }\n}\n\n// --- Espera a que se presione cualquier bot\u00f3n ---\nvoid wait_any_button() {\n    while (true) {\n        for (int i = 0; i &lt; 4; i++) {\n            if (!gpio_get(BUTTON_PINS[i])) { // Si se presiona\n                sleep_ms(50);               // Debounce inicial\n                while (!gpio_get(BUTTON_PINS[i])); // Espera a soltar\n                sleep_ms(50);               // Debounce final\n                return;                     // Sale de la funci\u00f3n\n            }\n        }\n    }\n}\n\n// --- Lee qu\u00e9 bot\u00f3n se presiona con timeout ---\nint read_button_timeout(int timeout_seconds) {\n    absolute_time_t end_time = make_timeout_time_ms(timeout_seconds * 1000); // Calcula momento final\n    while (absolute_time_diff_us(get_absolute_time(), end_time) &gt; 0) {      // Mientras no se acabe el tiempo\n        for (int i = 0; i &lt; 4; i++) {\n            if (!gpio_get(BUTTON_PINS[i])) { // Si se presiona bot\u00f3n\n                sleep_ms(50);                // Debounce\n                while (!gpio_get(BUTTON_PINS[i])); // Espera a soltar\n                sleep_ms(50);                // Debounce final\n                return i;                    // Devuelve \u00edndice del bot\u00f3n presionado\n            }\n        }\n    }\n    return -1; // Timeout, no se presion\u00f3 ning\u00fan bot\u00f3n\n}\n\n// --- Parpadea la ronda actual en el display ---\nvoid flash_round(uint8_t round_num, int times, int ms_delay) {\n    for (int i = 0; i &lt; times; i++) {\n        display_number_inverted(round_num);        // Muestra n\u00famero\n        sleep_ms(ms_delay);                        // Espera\n        for (int k = 0; k &lt; 7; k++) gpio_put(SEG_PINS[k], 1); // Apaga todos los segmentos\n        sleep_ms(ms_delay);                        // Espera antes del siguiente parpadeo\n    }\n}\n\n// --- Parpadea LEDs y muestra n\u00famero si el jugador falla ---\nvoid flash_error(int failed_round) {\n    display_number_inverted(failed_round);         // Muestra ronda donde fall\u00f3\n    for (int i = 0; i &lt; 3; i++) {                 // Parpadea 3 veces\n        for (int j = 0; j &lt; 4; j++) gpio_put(LED_PINS[j], 1); // Enciende todos los LEDs\n        sleep_ms(300);                             // Espera 300 ms\n        for (int j = 0; j &lt; 4; j++) gpio_put(LED_PINS[j], 0); // Apaga todos los LEDs\n        sleep_ms(300);                             // Espera 300 ms\n    }\n}\n\n// --- Funci\u00f3n principal ---\nint main() {\n    stdio_init_all();    // Inicializa la comunicaci\u00f3n serial (opcional)\n    init_hardware();     // Inicializa LEDs, botones y display\n\n    while (true) {       // Bucle infinito del juego\n        wait_any_button();                        // Espera a que el jugador presione un bot\u00f3n para iniciar\n        srand(to_us_since_boot(get_absolute_time())); // Inicializa semilla aleatoria con tiempo\n\n        int round = 0;                            // Empieza en ronda 0\n        bool game_over = false;\n\n        while (!game_over &amp;&amp; round &lt; MAX_ROUNDS) { // Mientras no haya terminado el juego\n            sequence[round] = rand() % 4;         // Genera LED aleatorio para la ronda\n\n            display_number_inverted(round + 1);   // Muestra n\u00famero de ronda\n\n            for (int i = 0; i &lt;= round; i++) blink_led(sequence[i]); // Reproduce secuencia de LEDs\n\n            for (int i = 0; i &lt;= round; i++) {   // Jugador intenta repetir la secuencia\n                int btn = read_button_timeout(5 + round); // Tiempo de respuesta aumenta con la ronda\n                if (btn == -1 || btn != sequence[i]) {    // Si falla o timeout\n                    game_over = true;\n                    flash_error(round + 1);              // Feedback visual de error\n                    break;\n                }\n                blink_led(btn);                           // Feedback visual si presiona correcto\n            }\n\n            if (!game_over) {                              // Si acierta, pasa a la siguiente ronda\n                round++;\n                if (round &lt; MAX_ROUNDS) flash_round(round + 1, 2, 300); // Parpadea n\u00famero de la siguiente ronda\n            }\n        }\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Salvando_el_semestre/","title":"Proyecto final","text":"<p>El proyecto final de la materia de sistemas embebidos consiste de un robot  de 12 x 12 x 12 que se puede mover por cuenta propia en un laberinto con paredes de 5 cm de alto.</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Salvando_el_semestre/#caracteristicas-de-mi-prototipo","title":"Caracter\u00edsticas de mi prototipo","text":"<p>Para la realizaci\u00f3n de mi prototipo opt\u00e9 por el uso de los siguientes componentes:</p> <ul> <li>Sensor Sharp 10-80 cm de tipo l\u00e1ser anal\u00f3gico.</li> <li>Motores amarillos.</li> <li>Aceler\u00f3metro MPU -6050</li> <li>Puente H MX 1508</li> <li>Switch</li> <li>Regulador de voltaje</li> <li>Pi pico 2</li> </ul>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Salvando_el_semestre/#complicaciones","title":"Complicaciones","text":"<p>El proyecto parec\u00eda muy f\u00e1cil al inicio y por lo mismo me confi\u00e9 de que saldr\u00eda r\u00e1pido, sin embargo definitivamente fue pensado como un proyecto final por una raz\u00f3n, y esque existen muchas variables que pueden salir mal en la construcci\u00f3n de este robot, entre las cuales me enfrente a:</p> <ul> <li>Los sensores miden desde un m\u00ednimo de 10 cm, y neceisto medir desde como 2 cm.</li> <li>Mi PCB ten\u00eda problemas al utilizar el puente H.</li> <li>Un motor no se mov\u00eda mientras que el otro s\u00ed, y no hab\u00eda ning\u00fan problema que pudieramos encontrar.</li> </ul>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Salvando_el_semestre/#pcb","title":"PCB","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Salvando_el_semestre/#franky-senior-el-que-si-se-sabe-la-de-chambear","title":"Franky Senior (el que si se sabe la de chambear)","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Salvando_el_semestre/#video-franky-senior-mi-bebe-el-nino-prodigo","title":"Video (Franky senior, mi bebe, el ni\u00f1o pr\u00f3digo)","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Salvando_el_semestre/#franky-junior-un-berrinchudo-no-le-mueve-literlamente-no-se-mueve-lo-odio-me-hace-llorar","title":"Franky junior (un berrinchudo, no le mueve, literlamente no se mueve, lo odio, me hace llorar)","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Salvando_el_semestre/#codigos-si-codigos-en-plural","title":"C\u00f3digos (s\u00ed, codigos en plural)","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Salvando_el_semestre/#primer-codigo","title":"Primer C\u00f3digo","text":"<p>Este c\u00f3digo sirve con un solo sensor para detectar adelante y cambia de direcci\u00f3n cuando sensa algo 10 cm adelante de \u00e9l.</p> <pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include \"hardware/adc.h\"\n\n// Pines MX1508\nconst uint IN1 = 2;   // Antes PWM, ahora ser\u00e1 SENTIDO (Tierra)\nconst uint IN2 = 3;   // Antes SENTIDO, ahora ser\u00e1 PWM\nconst uint IN3 = 4;   // Antes PWM, ahora ser\u00e1 SENTIDO (Tierra)\nconst uint IN4 = 5;   // Antes SENTIDO, ahora ser\u00e1 PWM\n\n// PWM\nconst uint16_t PWM_WRAP = 1000;   // 0..1000\n\n// Velocidad de ambos motores\nconst uint16_t DUTY_A = 700;      // Motor A\nconst uint16_t DUTY_B = 1400;     // Motor B\n\n// Sharp en GP28 (ADC2)\nconst uint SHARP_PIN = 28;\nconst uint SHARP_ADC_CHANNEL = 2;\n\n// Umbral aproximado para ~10 cm\nuint16_t THRESHOLD_ADC = 2000;\n\n// ========= Funciones auxiliares =========\n\nvoid set_pwm_level(uint gpio, uint16_t level) {\n    if (level &gt; PWM_WRAP) level = PWM_WRAP;\n    uint slice = pwm_gpio_to_slice_num(gpio);\n    pwm_set_chan_level(slice, pwm_gpio_to_channel(gpio), level);\n}\n\n// Lee el Sharp promediando varias muestras\nuint16_t read_sharp_adc() {\n    const int N = 10;\n    uint32_t acc = 0;\n    for (int i = 0; i &lt; N; i++) {\n        acc += adc_read();\n        sleep_us(200);\n    }\n    return (uint16_t)(acc / N);\n}\n\nint main() {\n    stdio_init_all();\n\n    // ===== CAMBIO DE SENTIDO AQUI =====\n    // Ahora IN2 y IN4 ser\u00e1n los pines PWM\n    gpio_set_function(IN2, GPIO_FUNC_PWM);\n    gpio_set_function(IN4, GPIO_FUNC_PWM);\n\n    uint sliceA = pwm_gpio_to_slice_num(IN2);\n    uint sliceB = pwm_gpio_to_slice_num(IN4);\n\n    pwm_set_wrap(sliceA, PWM_WRAP);\n    pwm_set_wrap(sliceB, PWM_WRAP);\n\n    pwm_set_enabled(sliceA, true);\n    pwm_set_enabled(sliceB, true);\n\n    // Pines de sentido (ahora IN1 e IN3 ser\u00e1n Tierra/0)\n    gpio_init(IN1); gpio_set_dir(IN1, GPIO_OUT);\n    gpio_init(IN3); gpio_set_dir(IN3, GPIO_OUT);\n\n    // Arrancar parados (ponemos los pines de sentido a 0)\n    gpio_put(IN1, 0);\n    gpio_put(IN3, 0);\n    set_pwm_level(IN2, 0);\n    set_pwm_level(IN4, 0);\n\n    // ===== ADC Sharp =====\n    adc_init();\n    adc_gpio_init(SHARP_PIN);                \n    adc_select_input(SHARP_ADC_CHANNEL);\n\n    sleep_ms(1000);\n\n    while (true) {\n        // Adelante (en sentido invertido)\n        // Mantenemos IN1 e IN3 en 0\n        gpio_put(IN1, 0);   \n        gpio_put(IN3, 0);   \n\n        // Encender motores aplicando PWM a IN2 e IN4\n        set_pwm_level(IN2, DUTY_A);\n        set_pwm_level(IN4, DUTY_B);\n\n        // Queremos avanzar hasta 6 s,\n        // pero revisando el Sharp cada 50 ms\n        const uint32_t MOVE_TIME_MS = 6000;\n        const uint32_t STEP_MS = 50;\n        uint32_t elapsed = 0;\n\n        while (elapsed &lt; MOVE_TIME_MS) {\n            adc_select_input(SHARP_ADC_CHANNEL);\n            uint16_t val = read_sharp_adc();\n\n            if (val &gt; THRESHOLD_ADC) {\n                // Objeto a ~10 cm -&gt; detener motores inmediatamente\n                set_pwm_level(IN2, 0);\n                set_pwm_level(IN4, 0);\n                break;\n            }\n\n            sleep_ms(STEP_MS);\n            elapsed += STEP_MS;\n        }\n\n        // Asegurar que est\u00e9 parado y esperar 3 s\n        set_pwm_level(IN2, 0);\n        set_pwm_level(IN4, 0);\n        sleep_ms(3000);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Salvando_el_semestre/#segundo-codigo","title":"Segundo C\u00f3digo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include \"hardware/adc.h\"\n\n// Pines MX1508 (Configuraci\u00f3n invertida como pediste)\nconst uint IN1 = 2;   // SENTIDO (Tierra)\nconst uint IN2 = 3;   // PWM\nconst uint IN3 = 4;   // SENTIDO (Tierra)\nconst uint IN4 = 5;   // PWM\n\n// PWM\nconst uint16_t PWM_WRAP = 1000;   // 0..1000\n\n// Velocidad de ambos motores\nconst uint16_t DUTY_A = 700;      // Motor A (Izquierdo)\nconst uint16_t DUTY_B = 1000;     // Motor B (Derecho)\n\n// Sharp en GP28 (ADC2)\nconst uint SHARP_PIN = 28;\nconst uint SHARP_ADC_CHANNEL = 2;\n\n// Umbral aproximado para ~10 cm\nuint16_t THRESHOLD_ADC = 2000;\n\n// Tiempo que dura el giro (ajusta esto si gira mucho o muy poco)\nconst uint32_t TIEMPO_GIRO_MS = 600; \n\n// ========= Funciones auxiliares =========\n\nvoid set_pwm_level(uint gpio, uint16_t level) {\n    if (level &gt; PWM_WRAP) level = PWM_WRAP;\n    uint slice = pwm_gpio_to_slice_num(gpio);\n    pwm_set_chan_level(slice, pwm_gpio_to_channel(gpio), level);\n}\n\n// Lee el Sharp promediando varias muestras\nuint16_t read_sharp_adc() {\n    const int N = 10;\n    uint32_t acc = 0;\n    for (int i = 0; i &lt; N; i++) {\n        acc += adc_read();\n        sleep_us(200);\n    }\n    return (uint16_t)(acc / N);\n}\n\nint main() {\n    stdio_init_all();\n\n    // ===== CONFIGURACI\u00d3N MOTORES (IN2/IN4 PWM) =====\n    gpio_set_function(IN2, GPIO_FUNC_PWM);\n    gpio_set_function(IN4, GPIO_FUNC_PWM);\n\n    uint sliceA = pwm_gpio_to_slice_num(IN2);\n    uint sliceB = pwm_gpio_to_slice_num(IN4);\n\n    pwm_set_wrap(sliceA, PWM_WRAP);\n    pwm_set_wrap(sliceB, PWM_WRAP);\n\n    pwm_set_enabled(sliceA, true);\n    pwm_set_enabled(sliceB, true);\n\n    // Pines de sentido a Tierra (0)\n    gpio_init(IN1); gpio_set_dir(IN1, GPIO_OUT);\n    gpio_init(IN3); gpio_set_dir(IN3, GPIO_OUT);\n    gpio_put(IN1, 0);\n    gpio_put(IN3, 0);\n\n    set_pwm_level(IN2, 0);\n    set_pwm_level(IN4, 0);\n\n    // ===== ADC Sharp =====\n    adc_init();\n    adc_gpio_init(SHARP_PIN);                \n    adc_select_input(SHARP_ADC_CHANNEL);\n\n    sleep_ms(1000);\n\n    while (true) {\n        // --- 1. AVANZAR ---\n        gpio_put(IN1, 0);   \n        gpio_put(IN3, 0);   \n        set_pwm_level(IN2, DUTY_A);\n        set_pwm_level(IN4, DUTY_B);\n\n        const uint32_t MOVE_TIME_MS = 6000;\n        const uint32_t STEP_MS = 50;\n        uint32_t elapsed = 0;\n        bool obstaculo_detectado = false;\n\n        while (elapsed &lt; MOVE_TIME_MS) {\n            adc_select_input(SHARP_ADC_CHANNEL);\n            uint16_t val = read_sharp_adc();\n\n            if (val &gt; THRESHOLD_ADC) {\n                obstaculo_detectado = true;\n                break; // Romper el ciclo de avance\n            }\n\n            sleep_ms(STEP_MS);\n            elapsed += STEP_MS;\n        }\n\n        // --- 2. SI HAY OBST\u00c1CULO: GIRAR A LA DERECHA ---\n        if (obstaculo_detectado) {\n            // A) Parar brevemente (para no quemar motores por inercia)\n            set_pwm_level(IN2, 0);\n            set_pwm_level(IN4, 0);\n            sleep_ms(200);\n\n            // B) Girar a la derecha\n            // Dejamos Motor A (IN2) encendido y apagamos Motor B (IN4)\n            set_pwm_level(IN2, DUTY_A); \n            set_pwm_level(IN4, 0);      \n            sleep_ms(TIEMPO_GIRO_MS);\n\n            // C) Parar giro\n            set_pwm_level(IN2, 0);\n            set_pwm_level(IN4, 0);\n            sleep_ms(200);\n\n            // D) 'continue' fuerza a reiniciar el while(true) ARRIBA\n            // as\u00ed el robot avanza inmediatamente sin esperar los 3 segundos.\n            continue; \n        }\n\n        // --- 3. SI SE ACAB\u00d3 EL TIEMPO (6s) SIN CHOCAR ---\n        set_pwm_level(IN2, 0);\n        set_pwm_level(IN4, 0);\n        sleep_ms(3000);\n    }\n\n    return 0;\n}\n</code></pre> <p>## Reflexiones finales</p> <p>Hubiera podido llegar a m\u00e1s si no fuera porque ten\u00eda muchos otros proyectos y ex\u00e1menes, otros factores que intervinieron:</p> <ul> <li>Mi equipo no se present\u00f3 a trabajar m\u00e1s que un d\u00eda.</li> <li>Mi equipo no se present\u00f3 a trabajar m\u00e1s que un d\u00eda.</li> <li>Y por \u00faltimo pero no menos importante, mi equipo solo se present\u00f3 a trabajar un d\u00eda.</li> </ul> <p>Gracias por su atenci\u00f3n.</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Segundo_examen/","title":"Segundo examen parcial","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0 \n#define UART_RX_PIN 1\n\n#define SERVO_PIN 2\nconst uint BTN1 = 4; // Botones del modo step\nconst uint BTN2 = 5;\nconst uint BTN3 = 3; // Bot\u00f3n para cambiar entre modos\n\nusing namespace std;\n\n// Lista global donde se guardan las posiciones del servo, con esto podemos usar la lista en cualquier funci\u00f3n\nint valores_guardados[3] = {0, 0, 0};\n\n// Variables compartidas entre el programa principal y la interrupci\u00f3n\nvolatile int modo_actual = 1;     // 1: write, 2: continuo, 3: step\nvolatile bool ciclo_activo = false;\n\n//Funci\u00f3n: borrar la lista de valores\nvoid borrar_lista() {\n    for (int i = 0; i &lt; 3; i++) valores_guardados[i] = 0;\n    printf(\"Lista borrada.\\n\");\n}\n\n//convertir un \u00e1ngulo (0\u2013180) a un valor de PWM \nuint16_t angle_to_level(uint16_t angle) {\n    // Convierte un \u00e1ngulo en microsegundos para el pulso del servo\n    float pulse_us = 1000.0f + (angle * 1000.0f / 180.0f);\n    // Convierte el tiempo a un nivel proporcional al periodo \n    return (uint16_t)((pulse_us / 20000.0f) * 65535);\n}\n\n//interrupci\u00f3n, sirve para cambiar entre los modos 1, 2 y 3\nvoid cambiar_modo(uint gpio, uint32_t events) {\n    if (gpio == BTN3) {\n        modo_actual++;\n        if (modo_actual &gt; 3) modo_actual = 1; // Regresa a modo 1 si pasa del 3\n        ciclo_activo = (modo_actual == 2);    // El modo continuo activa un ciclo\n        printf(\"\\nAhora est\u00e1s en el modo %d\\n\", modo_actual);\n    }\n}\n\nint main() {\n    stdio_init_all();\n    sleep_ms(2000);\n\n    printf(\"Bienvenido, actualmente te encuentras en el modo de entrenamiento, presiona el boton para moverte a otro modo\\n\");\n    printf(\"En este modo puedes escribir(write), remplazar(replace), y borrar(clear) 3 posiciones del servo\\n\");\n    printf(\"Escribe alguno de los comandos para hacer alguna accion\\n\");\n\n    //iniciar UART(comunicaci\u00f3n serial entre Pico y PC)\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    //iniciar PWM para controlar el servo\n    gpio_set_function(SERVO_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(SERVO_PIN);   // Cada pin PWM pertenece a un \"slice\"\n    uint chan  = pwm_gpio_to_channel(SERVO_PIN);     // Canal A o B\n    pwm_set_wrap(slice, 65535);                      // Valor m\u00e1ximo del contador PWM\n    float f_clk = 125000000.0f;                      // Frecuencia base del reloj (125 MHz)\n    float div = f_clk / (50.0f * 65536.0f);          // Calcula divisor para 50Hz (servo)\n    pwm_set_clkdiv(slice, div);\n    pwm_set_enabled(slice, true);\n\n    // --- Configurar los botones ---\n    gpio_init(BTN1); gpio_set_dir(BTN1, GPIO_IN); gpio_pull_up(BTN1);\n    gpio_init(BTN2); gpio_set_dir(BTN2, GPIO_IN); gpio_pull_up(BTN2);\n    gpio_init(BTN3); gpio_set_dir(BTN3, GPIO_IN); gpio_pull_up(BTN3);\n\n    // habilitar interrupci\u00f3n para BTN3\n    // \"&amp;\" se usa para pasar la direcci\u00f3n de la funci\u00f3n \"cambiar_modo, nos permite cambiar el valor de la variable directamente\"\n    // as\u00ed la Pico sabe qu\u00e9 funci\u00f3n ejecutar cuando se presiona el bot\u00f3n\n    gpio_set_irq_enabled_with_callback(BTN3, GPIO_IRQ_EDGE_FALL, true, &amp;cambiar_modo);\n\n    // Variables locales de uso general\n    string mensaje_usb = \"\", mensaje_uart = \"\";\n    int modo_index = 0;      \n    bool btn1_presionado = false, btn2_presionado = false;\n\n    //Bucle principal\n    while (true) {\n\n        // Leer texto que llega desde la consola USB \n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') { // Enter presionado\n                if (!mensaje_usb.empty()) {\n                    string comando = mensaje_usb;\n\n                    // WRITE\n                    if (comando == \"write\" || comando == \"escribir\" || comando == \"Write\" || comando == \"Escribir\") {\n                        printf(\"Ingresa 3 valores separados por comas (ej: 0,90,130):\\n\");\n                        string entrada_valores = \"\";\n                        while (true) {\n                            int c2 = getchar_timeout_us(0);\n                            if (c2 != PICO_ERROR_TIMEOUT) {\n                                if (c2 == '\\n' || c2 == '\\r') break;\n                                entrada_valores += (char)c2;\n                            }\n                        }\n\n                        // Procesar los valores separados por comas\n                        int i = 0; string temp = \"\"; bool error = false; int num_comas = 0;\n                        for (char c : entrada_valores) {\n                            if (c == ',') {\n                                num_comas++;\n                                if (i &lt; 3) {\n                                    int val = stoi(temp); // convierte un string a n\u00famero entero \"string to integrer\"\n                                    if (val &lt; 0 || val &gt; 180) { error = true; break; }\n                                    valores_guardados[i] = val;\n                                    temp = \"\"; i++;\n                                }\n                            } else temp += c;\n                        }\n                        // \u00daltimo valor despu\u00e9s de la \u00faltima coma\n                        if (!error &amp;&amp; !temp.empty() &amp;&amp; i &lt; 3) {\n                            int val = stoi(temp); \n                            if (val &lt; 0 || val &gt; 180) error = true;\n                            else valores_guardados[i] = val;\n                            i++;\n                        }\n\n                        //Validaciones (errores)\n                        if (error) printf(\"Que paso papito, dije valores de 0 a 180\\n\");\n                        else if (i != 3 || num_comas != 2) printf(\"Ponte pilas, recuerda que son 3 valores\\n\");\n                        else printf(\"Valores guardados: %d, %d, %d\\n\", valores_guardados[0], valores_guardados[1], valores_guardados[2]);\n                    } \n                    //borrado de lista ---\n                    else if (comando == \"clear\" || comando == \"borrar\" || comando == \"Clear\" || comando == \"Borrar\") {\n                        borrar_lista();\n                    }\n                    //reemplazar un valor espec\u00edfico ---\n                    else if (comando == \"replace\" || comando == \"reemplazar\" || comando == \"Replace\" || comando == \"Reemplazar\") {\n                        printf(\"Formato: Replace:posicion,valor (ej: Replace:1,130)\\n\");\n                        string entrada_replace = \"\";\n                        while (true) {\n                            int c2 = getchar_timeout_us(0);\n                            if (c2 != PICO_ERROR_TIMEOUT) {\n                                if (c2 == '\\n' || c2 == '\\r') break;\n                                entrada_replace += (char)c2;\n                            }\n                        }\n\n                        // Separar posici\u00f3n y valor\n                        int pos = -1, val = -1; string temp=\"\"; bool sep=false;\n                        for (char c : entrada_replace) {\n                            if (c == ',' &amp;&amp; !sep) {\n                                pos = stoi(temp)-1; temp=\"\"; sep=true;\n                            } else temp+=c;\n                        }\n                        if (sep &amp;&amp; !temp.empty()) val = stoi(temp);\n\n                        // Validaciones(error)\n                        if (pos&lt;0 || pos&gt;2) printf(\"Error: posici\u00f3n inv\u00e1lida\\n\");\n                        else if (val&lt;0 || val&gt;180) printf(\"Error: valor inv\u00e1lido\\n\");\n                        else {\n                            valores_guardados[pos]=val;\n                            printf(\"Valor reemplazado: pos%d = %d\\n\", pos+1, val);\n                            printf(\"Lista: %d, %d, %d\\n\", valores_guardados[0], valores_guardados[1], valores_guardados[2]);\n                        }\n                    }\n                    mensaje_usb=\"\";\n                }\n            } else mensaje_usb += (char)ch;\n        }\n\n        // STEP \n        bool b1 = gpio_get(BTN1)==0;\n        bool b2 = gpio_get(BTN2)==0; \n        if (modo_actual==3) {\n            if (b1 &amp;&amp; !btn1_presionado) {\n                if (modo_index&gt;0) modo_index--;\n            pwm_set_chan_level(slice, chan, angle_to_level(valores_guardados[modo_index]));\n            printf(\"Servo a %d\u00b0\\n\", valores_guardados[modo_index]);\n                btn1_presionado=true;\n            } else if (!b1) btn1_presionado=false;\n\n            if (b2 &amp;&amp; !btn2_presionado) {\n                if (modo_index&lt;2) modo_index++;\n            pwm_set_chan_level(slice, chan, angle_to_level(valores_guardados[modo_index]));\n                printf(\"Servo a %d\u00b0\\n\", valores_guardados[modo_index]);\n                btn2_presionado=true;\n            } else if (!b2) btn2_presionado=false;\n        }\n\n        // CONTINUO \n        if (modo_actual==2 &amp;&amp; ciclo_activo) {\n            bool vacia = (valores_guardados[0]==0 &amp;&amp; valores_guardados[1]==0 &amp;&amp; valores_guardados[2]==0);\n            if (vacia) {\n                printf(\"Error: no hay lista de valores\\n\");\n                sleep_ms(1500);\n            } else {\n                for (int i=0;i&lt;3;i++) {\n                 pwm_set_chan_level(slice, chan, angle_to_level(valores_guardados[i]));\n                    printf(\"pos%d: %d\\n\", i+1, valores_guardados[i]);\n                    for (int t=0;t&lt;15;t++) { // Espera total de 1.5 segundos\n                        sleep_ms(100);\n                        if (!ciclo_activo) break;  // Si se cambia de modo, salir\n                    }\n                    if (!ciclo_activo) break;\n                }\n            }\n        }\n\n        sleep_ms(10); \n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_1/","title":"Tarea 1","text":"<p>El objetivo de este trabajo consiste en investigar al menos 4 microcontroladores de distintas marcas que puedan ser utilizados para la fabricaci\u00f3n de una lampara para dormir y hacer una tabla comparativa de:</p> <ul> <li>Perifericos </li> <li>Memoria </li> <li>Ecosistema </li> <li>Costos </li> <li>Arquitectura </li> <li>Velocidad de trabajo </li> </ul>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_1/#proyecto","title":"Proyecto","text":"<p>Lampara para dormir que cambia el color y potencia de la luz para ayudar a inducir el sue\u00f1o.</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_1/#tabla-comparativa","title":"Tabla comparativa","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_1/#ranking-mejor-a-peor","title":"Ranking (mejor a peor)","text":"<ol> <li>ATmega328P :Es f\u00e1cil de programar en Arduino IDE, barato, y debido a su gran comunidad ya hay ejemplos y gu\u00edas f\u00e1ciles que se pueden utilizar como referencia.</li> <li>PIC16F877A :Cuenta con una memoria EEPROM (memoria de solo lectura programable y borrable el\u00e9ctricamente), que permite guardar datos incluso al estar apagada, ecosistema menos amigable, requiere MPLAB X IDE y compilador XC8, no es tan f\u00e1cil de programar con en Arduino.</li> <li>STM32F103RG :Este micro es muy poderoso (32 bits, 72 MHz) y con muchos perif\u00e9ricos, es muy r\u00e1pido, con mucha memoria y muy profesional, pero por lo mismo es m\u00e1s complejo de programar, requiere m\u00e1s energ\u00eda y es m\u00e1s costoso.</li> <li>ESP32 :Aunque es s\u00faper potente (Wi-Fi, Bluetooth, doble n\u00facleo a 240 MHz), todas esas caracter\u00edsticas sobran para una l\u00e1mpara.Su precio es el m\u00e1s alto, y es relativamente m\u00e1s complejo de configurar en comparaci\u00f3n con los dem\u00e1s</li> </ol>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_10/","title":"Tarea 10","text":"<p>El objetivo es por medio de una simulaci\u00f3n en WOKWI o en f\u00edsico leer un sensor RTC (Real Time Clock) y un aceler\u00f3metro.Todo esto se debe de realizar utilizando el m\u00e9todo de lectura y escritura de datos I2C.</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_10/#real-time-clock","title":"Real Time Clock","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/i2c.h\"\n#include &lt;stdio.h&gt;\n\n#define I2C_PORT i2c0\n#define RTC_SDA 4\n#define RTC_SCL 5\n#define RTC_ADDR 0x68  // Direcci\u00f3n del DS1307 o DS3231\n\n// Convierte de Decimal codificado en binario (BCD) a decimal\nuint8_t bcd_to_dec(uint8_t val) {\n    return ((val / 16) * 10) + (val % 16);\n}\n\n// Funci\u00f3n para leer la hora del RTC\nvoid rtc_read_time() {\n    uint8_t buffer[3];\n    uint8_t reg = 0x00;  // Registro inicial (segundos)\n\n    // Escribir direcci\u00f3n inicial de lectura\n    i2c_write_blocking(I2C_PORT, RTC_ADDR, &amp;reg, 1, true);//No env\u00eda STOP, deja el bus abierto para leer inmediatamente despu\u00e9s.\n    // Leer segundos, minutos y horas\n    i2c_read_blocking(I2C_PORT, RTC_ADDR, buffer, 3, false);// Ya termin\u00e9 de enviar los datos, cierro la comunicaci\u00f3n.\n\n    uint8_t seconds = bcd_to_dec(buffer[0] &amp; 0x7F);//Borra el bit 7, ya que ese no contiene informaci\u00f3n de los segundos\n    uint8_t minutes = bcd_to_dec(buffer[1]);\n    uint8_t hours = bcd_to_dec(buffer[2] &amp; 0x3F);\n\n    printf(\"Hora actual: %02d:%02d:%02d\\n\", hours, minutes, seconds);\n}\n\nint main() {\n    stdio_init_all();\n\n    // Inicializar I2C en los pines 0 (SDA) y 1 (SCL)\n    i2c_init(I2C_PORT, 100 * 1000);// se comunican a 100KHZ (velocidad est\u00e1ndar)\n    gpio_set_function(RTC_SDA, GPIO_FUNC_I2C);\n    gpio_set_function(RTC_SCL, GPIO_FUNC_I2C);\n    gpio_pull_up(RTC_SDA);// Activamos las resistencias de forma que est\u00e9 en 1 constante\n    gpio_pull_up(RTC_SCL);//de esta forma solo necesitamos bajara a GND no generar voltaje\n\n    sleep_ms(500);\n    printf(\"Lectura de hora desde RTC iniciada...\\n\");\n\n    while (true) {// Permite que mande la lectura de tiempo cada 1 segundos\n        rtc_read_time();\n        sleep_ms(1000);\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_10/#acelerometro","title":"Aceler\u00f3metro","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/i2c.h\"\n\n#define MPU6050_ADDR 0x68\n#define SDA_PIN 8\n#define SCL_PIN 9\n\nint main() {\n    stdio_init_all();\n    i2c_init(i2c0, 400 * 1000);\n    gpio_set_function(SDA_PIN, GPIO_FUNC_I2C);\n    gpio_set_function(SCL_PIN, GPIO_FUNC_I2C);\n    gpio_pull_up(SDA_PIN);\n    gpio_pull_up(SCL_PIN);\n\n    sleep_ms(1000);\n    printf(\"MPU6050 b\u00e1sico iniciado...\\n\");\n\n    // Despertar el sensor (quitar sleep mode)\n    uint8_t wake[2] = {0x6B, 0x00};\n    i2c_write_blocking(i2c0, MPU6050_ADDR, wake, 2, false);\n\n    uint8_t reg = 0x3B;\n    uint8_t data[14];\n    int16_t ax, ay, az, gx, gy, gz;\n\n    while (true) {\n        // Leer 14 bytes desde el registro 0x3B (aceler\u00f3metro y giroscopio)\n        i2c_write_blocking(i2c0, MPU6050_ADDR, &amp;reg, 1, true);\n        i2c_read_blocking(i2c0, MPU6050_ADDR, data, 14, false);\n\n        ax = (data[0] &lt;&lt; 8) | data[1];\n        ay = (data[2] &lt;&lt; 8) | data[3];\n        az = (data[4] &lt;&lt; 8) | data[5];\n        gx = (data[8] &lt;&lt; 8) | data[9];\n        gy = (data[10] &lt;&lt; 8) | data[11];\n        gz = (data[12] &lt;&lt; 8) | data[13];\n\n        printf(\"A[X:%6d Y:%6d Z:%6d] | G[X:%6d Y:%6d Z:%6d]\\n\",\n               ax, ay, az, gx, gy, gz);\n\n        sleep_ms(500);\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_10/#diagrama-de-conexiones","title":"Diagrama de conexiones","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_2/","title":"Tarea 2","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_2/#objetivo","title":"Objetivo","text":"<p>Realizar las siguientes tareas usando codigos que ocupen logica y mascaras, no se pueden poner todas las combinaciones:</p> <ol> <li>Contador binario 4 bits:En cuentro leds debe mostrarse cad segundo la representacion binaria del 0 al 15.</li> <li>Barrido de leds:Correr un \u201c1\u201d por cuatro LEDs P0..P3 y regresar (0\u21921\u21922\u21923\u21922\u21921).</li> <li>Secuencia en c\u00f3digo Gray:Es una representaci\u00f3n binaria donde cada valor sucesivo difiere en un solo bit del valor anterior.</li> </ol>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_2/#contador-binario-de-4-bits","title":"Contador binario de 4 bits","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n\nint main() {\n    const uint LEDS[4] = {0, 1, 2, 3};\n\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n\n    while (true) {\n        for (int count = 0; count &lt; 16; count++) {\n            for (int i = 0; i &lt; 4; i++) {\n                if (count &amp; (1 &lt;&lt; i))\n                    sio_hw-&gt;gpio_set = (1u &lt;&lt; LEDS[i]);\n                else\n                    sio_hw-&gt;gpio_clr = (1u &lt;&lt; LEDS[i]);\n            }\n            sleep_ms(1000);\n        }\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_2/#barrido-de-leds","title":"Barrido de leds","text":"<pre><code>#include \"pico/stdlib.h\"\n\n#define NUM_LEDS 4\n#define DELAY_MS 150\n\nint main() {\n    const uint LED_PINS[NUM_LEDS] = {0, 1, 2, 3};\n\n    for (int i = 0; i &lt; NUM_LEDS; i++) {\n        gpio_init(LED_PINS[i]);\n        gpio_set_dir(LED_PINS[i], GPIO_OUT);\n    }\n\n    int current_led = 0;\n    int direction = 1;\n\n    while (true) {\n        gpio_put(LED_PINS[current_led], 1);\n        sleep_ms(DELAY_MS);\n        gpio_put(LED_PINS[current_led], 0);\n\n        current_led += direction;\n\n        if (current_led == 0 || current_led == NUM_LEDS - 1) {\n            direction *= -1;\n        }\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_2/#secuencia-en-codigo-gray","title":"Secuencia en c\u00f3digo Gray","text":"<pre><code>#include \"pico/stdlib.h\"\n#include &lt;stdint.h&gt;\n\n#define NUM_LEDS 4\n#define DELAY_MS 1000\n\nuint8_t binary_to_gray(uint8_t n) {\n    return n ^ (n &gt;&gt; 1);\n}\n\nint main() {\n    const uint LED_PINS[NUM_LEDS] = {0, 1, 2, 3};\n\n    for (int i = 0; i &lt; NUM_LEDS; i++) {\n        gpio_init(LED_PINS[i]);\n        gpio_set_dir(LED_PINS[i], GPIO_OUT);\n    }\n\n    uint8_t counter = 0;\n\n    while (true) {\n        uint8_t gray_value = binary_to_gray(counter);\n\n        for (int i = 0; i &lt; NUM_LEDS; i++) {\n            bool bit_value = (gray_value &gt;&gt; i) &amp; 1;\n            gpio_put(LED_PINS[i], bit_value);\n        }\n\n        sleep_ms(DELAY_MS);\n\n        counter = (counter + 1) % 16;\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_2/#diagrama-de-conexion","title":"Diagrama de conexi\u00f3n","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_3/","title":"Tarea 3","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_3/#objetivo","title":"Objetivo","text":"<p>Crear los siguientes c\u00f3digos usando l\u00f3gica y m\u00e1scaras (no se vale enumerar todas las combinaciones con if):</p> <p>Compuertas b\u00e1sicas AND / OR / XOR con 2 botones</p> <p>Qu\u00e9 debe hacer: Con dos botones A y B (pull-up; presionado=0) enciende tres LEDs que muestren en paralelo los resultados de AND, OR y XOR. En el video muestra las 4 combinaciones (00, 01, 10, 11).</p> <p>Selector c\u00edclico de 4 LEDs con avance/retroceso</p> <p>Qu\u00e9 debe hacer: Mant\u00e9n un \u00fanico LED encendido entre LED0..LED3. Un bot\u00f3n AVANZA (0\u21921\u21922\u21923\u21920) y otro RETROCEDE (0\u21923\u21922\u21921\u21920). Un push = un paso (antirrebote por flanco: si dejas presionado no repite). En el video demuestra en ambos sentidos.</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_3/#compuertas-andorxor","title":"Compuertas AND/OR/XOR","text":"<pre><code>#include \"pico/stdlib.h\"   \n\n\n#define BTN_A 4\n#define BTN_B 5\n#define LED_AND 0\n#define LED_OR  1\n#define LED_XOR 2\n\nint main() {\n    stdio_init_all();  \n\n    // Configurar botones como entrada con resistencia pull-up\n    gpio_init(BTN_A);\n    gpio_set_dir(BTN_A, false);   // false = input\n    gpio_pull_up(BTN_A);          // activa resistencia pull-up\n\n    gpio_init(BTN_B);\n    gpio_set_dir(BTN_B, false);   \n    gpio_pull_up(BTN_B);\n\n    // Configurar LEDs como salida\n    gpio_init(LED_AND);\n    gpio_set_dir(LED_AND, true);  // true = output\n\n    gpio_init(LED_OR);\n    gpio_set_dir(LED_OR, true);\n\n    gpio_init(LED_XOR);\n    gpio_set_dir(LED_XOR, true);\n\n\n    while (true) {\n\n        uint A = !gpio_get(BTN_A);  // lee bot\u00f3n A \n        uint B = !gpio_get(BTN_B);  // lee bot\u00f3n B\n\n        // l\u00f3gica con m\u00e1scaras\n        uint res_and = A &amp; B;   \n        uint res_or  = A | B;   \n        uint res_xor = A ^ B;   \n\n        // mandamos el resultado a los LEDs\n        gpio_put(LED_AND, res_and);\n        gpio_put(LED_OR,  res_or);\n        gpio_put(LED_XOR, res_xor);\n\n        sleep_ms(50); \n    }\n}\n</code></pre> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\nconst uint LED_PINS[] = {0, 1, 2, 3};\nconst int NUM_LEDS = sizeof(LED_PINS) / sizeof(LED_PINS[0]);\n\nconst uint LEFT_BUTTON_PIN = 4;\nconst uint RIGHT_BUTTON_PIN = 5;\n\nconst int DEBOUNCE_DELAY_MS = 100;\n\nvoid setup_gpio();\nvoid update_leds(int current_led_index);\n\nint main() {\n    stdio_init_all();\n    setup_gpio();\n\n    int current_led = 0;\n    update_leds(current_led);\n\n    while (true) {\n        if (!gpio_get(RIGHT_BUTTON_PIN)) {\n            sleep_ms(DEBOUNCE_DELAY_MS);\n            if (!gpio_get(RIGHT_BUTTON_PIN)) {\n                current_led++;\n                if (current_led &gt;= NUM_LEDS) {\n                    current_led = 0;\n                }\n                update_leds(current_led);\n                while (!gpio_get(RIGHT_BUTTON_PIN));\n            }\n        }\n\n        if (!gpio_get(LEFT_BUTTON_PIN)) {\n            sleep_ms(DEBOUNCE_DELAY_MS);\n            if (!gpio_get(LEFT_BUTTON_PIN)) {\n                current_led--;\n                if (current_led &lt; 0) {\n                    current_led = NUM_LEDS - 1;\n                }\n                update_leds(current_led);\n                while (!gpio_get(LEFT_BUTTON_PIN));\n            }\n        }\n    }\n    return 0;\n}\n\nvoid setup_gpio() {\n    for (int i = 0; i &lt; NUM_LEDS; i++) {\n        gpio_init(LED_PINS[i]);\n        gpio_set_dir(LED_PINS[i], GPIO_OUT);\n    }\n\n    gpio_init(LEFT_BUTTON_PIN);\n    gpio_set_dir(LEFT_BUTTON_PIN, GPIO_IN);\n    gpio_pull_up(LEFT_BUTTON_PIN);\n\n    gpio_init(RIGHT_BUTTON_PIN);\n    gpio_set_dir(RIGHT_BUTTON_PIN, GPIO_IN);\n    gpio_pull_up(RIGHT_BUTTON_PIN);\n}\n\nvoid update_leds(int current_led_index) {\n    for (int i = 0; i &lt; NUM_LEDS; i++) {\n        if (i == current_led_index) {\n            gpio_put(LED_PINS[i], 1);\n        } else {\n            gpio_put(LED_PINS[i], 0);\n        }\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_3/#diagrama-de-conexion","title":"Diagrama de conexi\u00f3n","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_4/","title":"Tarea 4","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_4/#objetivo","title":"Objetivo","text":"<p>Programar un mini-Pong con 5 LEDs en l\u00ednea y 2 botones usando interrupciones (ISR) para registrar el \u201cgolpe\u201d del jugador exactamente cuando la \u201cpelota\u201d (un LED encendido) llega al extremo de su lado.</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_4/#reglas-del-codigo","title":"Reglas del c\u00f3digo","text":"<ol> <li>Pelota: es un \u00fanico LED encendido que se mueve autom\u00e1ticamente de un extremo al otro (L1\u2192L5\u2192L1\u2026) a un ritmo fijo.</li> <li>Golpe con ISR:cada bot\u00f3n genera una interrupci\u00f3n.</li> </ol> <p>El BTN_L solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L1.</p> <p>El BTN_R solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L5.</p> <p>Si coincide, la pelota rebota: invierte su direcci\u00f3n.</p> <p>Si no coincide (la pelota no est\u00e1 en el \u00faltimo LED de ese lado), el bot\u00f3n se ignora.</p> <ol> <li> <p>Fallo y punto:si la pelota alcanza L1 y no hubo golpe v\u00e1lido del lado izquierdo en ese momento, anota el jugador derecho. An\u00e1logamente, si alcanza L5 sin golpe v\u00e1lido, anota el jugador izquierdo.</p> </li> <li> <p>Indicador de punto:al anotar, se parpadea el LED de punto 3 veces del jugador que meti\u00f3 el punto .</p> </li> <li> <p>Reinicio tras punto:despu\u00e9s del parpadeo, la pelota se reinicia en el centro (L3) y comienza a moverse hacia el jugador que meti\u00f3 el punto.</p> </li> <li> <p>Inicio del juego:al encender, la pelota inicia en L3 y no se mueve hasta que se presione un boton y debera moverse a la direccion opuesta del boton presionado.</p> </li> </ol>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_4/#codigo-pong","title":"C\u00f3digo PONG","text":"<pre><code>//Pong version final\n\n#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n#include \"hardware/watchdog.h\"\n\n#define NUM_LEDS 5\n#define DELAY_MS 400\n\nconst uint BTN1 = 5; // bot\u00f3n izquierdo\nconst uint BTN2 = 6; // bot\u00f3n derecho\nconst uint LED_PINS[NUM_LEDS] = {0, 1, 2, 3, 4};\nconst uint LEDG1 = 8; // LED indicador derecha\nconst uint LEDG2 = 7; // LED indicador izquierda\n\nvolatile bool REBOTE1 = false;\nvolatile bool REBOTE2 = false;\n\nvoid button_isr(uint gpio, uint32_t events)\n{\n    if (gpio == BTN1)\n        REBOTE1 = true;\n    else if (gpio == BTN2)\n        REBOTE2 = true;\n}\n\n// --- Funci\u00f3n para indicar un punto ---\nvoid score_point(uint led)\n{\n    for (int i = 0; i &lt; 3; i++)\n    {\n        gpio_put(led, 1);\n        sleep_ms(150);\n        gpio_put(led, 0);\n        sleep_ms(150);\n    }\n}\n\nint main()\n{\n    // Inicializar LEDs de victoria\n    gpio_init(LEDG1);\n    gpio_set_dir(LEDG1, true);\n    gpio_put(LEDG1, 0);\n    gpio_init(LEDG2);\n    gpio_set_dir(LEDG2, true);\n    gpio_put(LEDG2, 0);\n\n    // Inicializar botones\n    gpio_init(BTN1);\n    gpio_set_dir(BTN1, false);\n    gpio_pull_up(BTN1);\n    gpio_set_irq_enabled_with_callback(BTN1, GPIO_IRQ_EDGE_FALL, true, &amp;button_isr);\n\n    gpio_init(BTN2);\n    gpio_set_dir(BTN2, false);\n    gpio_pull_up(BTN2);\n    gpio_set_irq_enabled(BTN2, GPIO_IRQ_EDGE_FALL, true);\n\n    // Inicializar LEDs del juego\n    for (int i = 0; i &lt; NUM_LEDS; i++)\n    {\n        gpio_init(LED_PINS[i]);\n        gpio_set_dir(LED_PINS[i], true);\n    }\n\n    int current_led = NUM_LEDS / 2;\n    int direction = 0; // 0 = stopped, 1 = right, -1 = left\n    bool game_started = false;\n\n    // Show ball at center before game starts\n    gpio_put(LED_PINS[current_led], 1);\n\n    while (true)\n    {\n        if (!game_started)\n        {\n            if (REBOTE1)\n            {\n                direction = 1; // Move right\n                game_started = true;\n                REBOTE1 = false;\n                gpio_put(LED_PINS[current_led], 0); // Turn off center LED\n            }\n            else if (REBOTE2)\n            {\n                direction = -1; // Move left\n                game_started = true;\n                REBOTE2 = false;\n                gpio_put(LED_PINS[current_led], 0); // Turn off center LED\n            }\n            else\n            {\n                // Wait for button press to start\n                tight_loop_contents();\n                continue;\n            }\n        }\n\n        gpio_put(LED_PINS[current_led], 1);\n        sleep_ms(DELAY_MS);\n        gpio_put(LED_PINS[current_led], 0);\n\n        current_led += direction;\n\n        // PELOTA IZQUIERDA\n        if (current_led == -1)\n        {\n            if (REBOTE1)\n            {\n                direction = 1;\n                current_led = 0;\n                REBOTE1 = false;\n            }\n            else\n            {\n                // Jugador dos (derehca) scores\n                score_point(LEDG1);\n                current_led = NUM_LEDS / 2; // Resetea al centro\n                direction = 1;              // Move towards winner (right)\n            }\n        }\n\n        // PELOTA DERECHA\n        if (current_led == NUM_LEDS)\n        {\n            if (REBOTE2)\n            {\n                direction = -1;\n                current_led = NUM_LEDS - 1;\n                REBOTE2 = false;\n            }\n            else\n            {\n                // Player 1 (left) scores\n                score_point(LEDG2);\n                current_led = NUM_LEDS / 2; // Reset to center\n                direction = -1;             // Move towards winner (left)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_4/#diagrama-de-conexion","title":"Diagrama de conexi\u00f3n","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_4/#se-estan-respetando-los-limites-de-corriente-de-los-pines-de-la-pico-2","title":"\u00bfSe est\u00e1n respetando los l\u00edmites de corriente de los pines de la Pico 2?","text":"<p>\u00bfAcaso te hiciste esa pregunta al ver este trabajo?, pues yo tampoco pero gracias a Dios no quemamos ninguno de los pines, entonces hagamos el c\u00e1lculo de porque no cometimos la tonter\u00eda de quemarlos:</p> <p>Tenemos los siguientes componentes conectados a la Pico 2:</p> <ul> <li>7 Leds:todos con resistencias de 1K conectadas a GND.</li> <li>2 Push button:tenemos 2 Push buttons conectados igual a resistencias de 1K conectadas a GND.</li> </ul> <p>Para el c\u00e1lculo usamos la Ley de Ohm, que funciona de forma que la corriente es igual a (Voltaje del pin-Voltaje del Led)/Resistencia, los pines tienen un voltaje de salida de 3.3V y los leds est\u00e1ndar consumen 2V, por lo que:</p> <p>(3.3V-2V/1 Kilo Ohm)=1.3 mA</p> <p>Los botones con resistencia de 1 k\u03a9 en serie limitan la corriente cuando se presionan, por lo que los calculos nos dar\u00edan (Voltaje de pin/resistencia), lo que nos da:</p> <p>(3.3V/1 Kilo Ohm)=3.3 mA</p> <p>Los GPIO de la Pico 2 soportan hasta 12\u202fmA recomendados por pin, con m\u00e1ximo absoluto de 16\u202fmA, y la corriente total del chip recomienda 50\u202fmA en todos los pines juntos, por lo que se pude notar que se est\u00e1 dentro del l\u00edmite permitido.</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_5/","title":"Tarea 5","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_5/#ejercicio-1","title":"Ejercicio 1","text":"<p>Genera una onda cuadrada por toggle de un pin de salida en la ISR de ALARM0, con rearme acumulativo y periodo nominal definido por ti (p. ej., 100 \u00b5s\u20135 ms). Mide con osciloscopio:</p> <ol> <li>Periodo promedio y tolerancia.</li> <li>Jitter pico-a-pico y, si tu equipo lo permite, RMS.</li> <li>Describe la configuraci\u00f3n del osciloscopio (acoplamiento, escala de tiempo/voltaje, modo de medici\u00f3n). No cambiar la resoluci\u00f3n del timer (mantener modo \u00b5s).</li> </ol> <pre><code>// Blink con timer (SDK alto nivel): cambia BLINK_MS para ajustar\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n\n#define LED_PIN PICO_DEFAULT_LED_PIN\nstatic const int BLINK_MS = 250;  // &lt;-- ajusta tu periodo aqu\u00ed\n\nbool blink_cb(repeating_timer_t *t) {\n    static bool on = false;\n    gpio_put(LED_PIN, on = !on);\n    return true; // seguir repitiendo la alarma\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    repeating_timer_t timer;\n    // Programa una interrupci\u00f3n peri\u00f3dica cada BLINK_MS:\n    add_repeating_timer_ms(BLINK_MS, blink_cb, NULL, &amp;timer);\n\n    while (true) {\n        // El trabajo \"pesado\" deber\u00eda ir aqu\u00ed (no en la ISR).\n        tight_loop_contents();\n    }\n}\n</code></pre> <p></p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_5/#ejercicio-2","title":"Ejercicio 2","text":"<p>Genera una se\u00f1al por toggle en la ISR de ALARM0, primero en modo \u00b5s y luego en modo ciclos de clk_sys (mismo periodo nominal). En ambos casos:</p> <ol> <li>Usa rearme acumulativo.</li> <li>Mant\u00e9n el resto del c\u00f3digo id\u00e9ntico</li> <li>Con el osciloscopio, mide y registra para cada modo:periodo promedio y desviaci\u00f3n respecto al nominal, Jitter pico-a-pico y/o RMS, Compara resultados y discute el compromiso entre resoluci\u00f3n de tick y horizonte de programaci\u00f3n.</li> </ol> <pre><code>// Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       PICO_DEFAULT_LED_PIN\n#define ALARM_NUM     0  // usaremos la alarma 0\n\n// Calcula el n\u00famero de IRQ para esa alarma \n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 500000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre> <p></p> <p>La diferencia se dio porque en el segundo c\u00f3digo estoy trabajando directamente con los registros y las interrupciones, y ah\u00ed la precisi\u00f3n depende del tiempo que tarda el procesador en atender la interrupci\u00f3n y volver a programar el siguiente evento. Ese peque\u00f1o retraso se acumula y hace que la se\u00f1al no sea tan exacta. En cambio, el primer c\u00f3digo usa la funci\u00f3n del SDK, que ya est\u00e1 optimizada para corregir esos retardos y mantener el temporizador m\u00e1s estable, por eso en el osciloscopio obtuve una se\u00f1al m\u00e1s uniforme.</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_6/","title":"Tarea 6","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_6/#objetivo","title":"Objetivo","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_6/#ejercicio-1","title":"Ejercicio 1","text":"<ul> <li> <p>Programa cuatro alarmas / cuatro LEDs a distintas frecuencias.</p> </li> <li> <p>Configurar ALARM0..ALARM3 del timer de sistema en modo \u00b5s. Cada alarma controla un LED distinto con un periodo propio. </p> </li> </ul> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n// Definimos los pins\nconst uint LED_PINS[] = {0, 1, 2, 3};\nconst uint32_t PERIODS_US[] = {200000, 500000, 1000000, 2000000};\n#define NUM_LEDS 4\n\n// Programaic\u00f3n de la ISR universal para las 4 alarmas\nvoid timer_isr() {\n    uint64_t now = timer_hw-&gt;timerawl; //tiempo actual del sistema en microsegundos\n\n    for (int i = 0; i &lt; NUM_LEDS; i++) {\n        if (timer_hw-&gt;intr &amp; (1u &lt;&lt; i)) {   // Verificar interrupci\u00f3n de alarma i\n            gpio_xor_mask(1u &lt;&lt; LED_PINS[i]); // Con la mascara de XOR cambiamos el esta\n            timer_hw-&gt;alarm[i] = now + PERIODS_US[i]; // Reprogramar alarma, Se suma PERIODS_US[i] para que la pr\u00f3xima interrupci\u00f3n ocurra despues de ese tiempo\n            timer_hw-&gt;intr = (1u &lt;&lt; i);  // Con el 1 limpiamos la flag, con 0 no se hace nada\n        }\n    }\n}\n\nint main() {\n    stdio_init_all();\n\n    //Configuraciones de los pines de los leds\n\n\n    for (int i = 0; i &lt; NUM_LEDS; i++) {\n        gpio_init(LED_PINS[i]);\n        gpio_set_dir(LED_PINS[i], true);\n    }\n\n    //Configuraci\u00f3n de las interrupciones del timer\n    irq_set_exclusive_handler(TIMER0_IRQ_0, timer_isr);  \n    irq_set_enabled(TIMER0_IRQ_0, true);\n\n    // Alarmas\n    uint64_t now = timer_hw-&gt;timerawl;\n    for (int i = 0; i &lt; NUM_LEDS; i++) {\n        timer_hw-&gt;alarm[i] = now + PERIODS_US[i];//Con esto arranca las alarmas desde el momento en el que se inicializa\n    }\n\n    //Con esto habilitamos la funci\u00f3n de interrumpir, si no lo hacemos, las interrupciones \n    //no funcionan, por lo que activamos los 4 bits\n    timer_hw-&gt;inte = (1u &lt;&lt; 0) | (1u &lt;&lt; 1) | (1u &lt;&lt; 2) | (1u &lt;&lt; 3);\n\n    //loop de repetici\u00f3n (1) significa que se mantenga repiti\u00e9ndose\n    while (1) {\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_6/#ejercicio-2","title":"Ejercicio 2","text":"<p>Modificar el pong, para tener dos botones adicionales, que suban y bajen la velocidad del juego sin delay.</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define NUM_LEDS 5\n#define DELAY_MIN 100\n#define DELAY_MAX 1000\n#define DELAY_STEP 100\n\nconst uint BTN1 = 5;     // bot\u00f3n izquierdo\nconst uint BTN2 = 6;     // bot\u00f3n derecho\nconst uint BTN_UP = 16;   // subir velocidad\nconst uint BTN_DOWN = 17;// bajar velocidad\nconst uint LED_PINS[NUM_LEDS] = {0, 1, 2, 3, 4};\nconst uint LEDG1 = 8;    // LED indicador derecha\nconst uint LEDG2 = 7;    // LED indicador izquierda\n\nvolatile bool REBOTE1 = false;\nvolatile bool REBOTE2 = false;\nvolatile bool SPEED_UP = false;\nvolatile bool SPEED_DOWN = false;\n\nvoid button_isr(uint gpio, uint32_t events) {\n    if (gpio == BTN1) REBOTE1 = true;\n    else if (gpio == BTN2) REBOTE2 = true;\n    else if (gpio == BTN_UP) SPEED_UP = true;\n    else if (gpio == BTN_DOWN) SPEED_DOWN = true;\n}\n\nvoid score_point(uint led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(150);\n        gpio_put(led, 0);\n        sleep_ms(150);\n    }\n}\n\nint main() {\n    // LEDs de victoria\n    gpio_init(LEDG1); gpio_set_dir(LEDG1, true);\n    gpio_init(LEDG2); gpio_set_dir(LEDG2, true);\n\n    // Botones\n    gpio_init(BTN1); gpio_set_dir(BTN1, false); gpio_pull_up(BTN1);\n    gpio_set_irq_enabled_with_callback(BTN1, GPIO_IRQ_EDGE_FALL, true, &amp;button_isr);\n\n    gpio_init(BTN2); gpio_set_dir(BTN2, false); gpio_pull_up(BTN2);\n    gpio_set_irq_enabled(BTN2, GPIO_IRQ_EDGE_FALL, true);\n\n    gpio_init(BTN_UP); gpio_set_dir(BTN_UP, false); gpio_pull_up(BTN_UP);\n    gpio_set_irq_enabled(BTN_UP, GPIO_IRQ_EDGE_FALL, true);\n\n    gpio_init(BTN_DOWN); gpio_set_dir(BTN_DOWN, false); gpio_pull_up(BTN_DOWN);\n    gpio_set_irq_enabled(BTN_DOWN, GPIO_IRQ_EDGE_FALL, true);\n\n    // LEDs del juego\n    for (int i = 0; i &lt; NUM_LEDS; i++) {\n        gpio_init(LED_PINS[i]);\n        gpio_set_dir(LED_PINS[i], true);\n    }\n\n    int current_led = NUM_LEDS / 2;\n    int direction = 0;\n    bool game_started = false;\n    int delay_ms = 400; // velocidad inicial\n\n    gpio_put(LED_PINS[current_led], 1);\n\n    while (true) {\n        // Ajustar velocidad (nota: se eval\u00faa **una vez por ciclo**)\n        if (SPEED_UP) {\n            if (delay_ms &gt; DELAY_MIN) delay_ms -= DELAY_STEP;\n            SPEED_UP = false;\n        }\n        if (SPEED_DOWN) {\n            if (delay_ms &lt; DELAY_MAX) delay_ms += DELAY_STEP;\n            SPEED_DOWN = false;\n        }\n\n        // Inicio del juego\n        if (!game_started) {\n            if (REBOTE1) { direction = 1; game_started = true; REBOTE1 = false; gpio_put(LED_PINS[current_led], 0);}\n            else if (REBOTE2) { direction = -1; game_started = true; REBOTE2 = false; gpio_put(LED_PINS[current_led], 0);}\n            else continue;\n        }\n\n        gpio_put(LED_PINS[current_led], 1);\n        sleep_ms(delay_ms);  // &lt;&lt;&lt;&lt;&lt;&lt; el delay depende del bot\u00f3n\n        gpio_put(LED_PINS[current_led], 0);\n\n        current_led += direction;\n\n        if (current_led == -1) {\n            if (REBOTE1) { direction = 1; current_led = 0; REBOTE1 = false; }\n            else { score_point(LEDG1); current_led = NUM_LEDS/2; direction = 1; }\n        }\n        if (current_led == NUM_LEDS) {\n            if (REBOTE2) { direction = -1; current_led = NUM_LEDS - 1; REBOTE2 = false; }\n            else { score_point(LEDG2); current_led = NUM_LEDS/2; direction = -1; }\n        }\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_6/#diagrama-de-conexion","title":"Diagrama de conexi\u00f3n","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_7/","title":"Tarea 7","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_7/#tarea-71","title":"Tarea 7.1","text":"<p>Implementar un circuito con un motor DC controlado mediante PWM variando el duty cycle.</p> <p>Usar 2 botones para seleccionar entre 3 velocidades predefinidas (baja, media y alta).</p> <p>Documentar:</p> <ul> <li> <p>Valores de duty usados, con el porque.</p> </li> <li> <p>Circuito</p> </li> <li> <p>Codigo</p> </li> </ul> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define LED_PIN 1\nconst uint BTN1 = 2; \nconst uint BTN2 = 3; \n#define F_PWM_HZ 2000\n#define TOP 1022\n\nint main() {\n    stdio_init_all();\n\n    // Inicializar botones con pull-up\n    gpio_init(BTN1); gpio_set_dir(BTN1, GPIO_IN); gpio_pull_up(BTN1);\n    gpio_init(BTN2); gpio_set_dir(BTN2, GPIO_IN); gpio_pull_up(BTN2);\n\n    // Configurar LED como PWM\n    gpio_set_function(LED_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(LED_PIN);\n    uint chan  = pwm_gpio_to_channel(LED_PIN);\n\n    float f_clk = 125000000.0f;\n    float div = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n    pwm_set_chan_level(slice, chan, 0); // inicia apagado\n    pwm_set_enabled(slice, true);\n\n    int level = 622;  // nivel inicial\n\n    // Con esto podemos hacer que solo se tenga que presionar el boton 1 vez\n    bool btn1_presionado = false;\n    bool btn2_presionado = false;\n\n    while (true) {\n        // Leer botones\n        bool b1 = gpio_get(BTN1) == 0;\n        bool b2 = gpio_get(BTN2) == 0;\n\n        // El boton 1 disminuye el nivel 200\n        if (b1 &amp;&amp; !btn1_presionado) {\n            level -= 200;\n            if (level &lt; 0) level = 0; // limite m\u00ednimo\n            btn1_presionado = true;\n        } else if (!b1) {\n            btn1_presionado = false;\n        }\n\n        // BTN2 \u2192 aumentar nivel 200\n        if (b2 &amp;&amp; !btn2_presionado) {// Si el boton esta presionado y b2 es 1\n            level += 200;\n            if (level &gt; TOP) level = TOP; // limite en el TOP\n            btn2_presionado = true;\n        } else if (!b2) {\n            btn2_presionado = false;//Con esto mantenemos registro de si estan presionados o no, para usar como referencia\n        }\n\n        // Aplicar PWM\n        pwm_set_chan_level(slice, chan, level);\n\n\n    }\n}\n</code></pre> <p></p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_7/#tarea-72","title":"Tarea 7.2","text":"<p>Programar un buzzer piezoel\u00e9ctrico para reproducir una melod\u00eda reconocible.</p> <p>Variar la frecuencia del PWM para las notas, manteniendo el duty en 50 %.</p> <p>Cada nota debe incluir su frecuencia y duraci\u00f3n en el c\u00f3digo.</p> <p>Documentar:</p> <ul> <li> <p>Tabla con notas, frecuencias y duraci\u00f3n usadas.</p> </li> <li> <p>Evidencia en audio o video de la melod\u00eda funcionando.</p> </li> </ul> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define BUZZER_PIN 5\n#define TOP 2048\n\n// Notas\n#define FAs 740.0f\n#define RE  587.0f  \n#define SI  494.0f\n#define MI  659.0f\n#define SOLs 831.0f\n#define LA  880.0f\n#define DOs 988.0f\n\n// Duraciones\n#define CORCHEA 214\n#define SILENCIO 214  // Los espacios son silencios de 214ms\n\nvoid tocar_nota(uint slice, uint chan, float frecuencia, int duracion) {\n    if (frecuencia &gt; 1.0f) {\n        float f_clk = 150000000.0f;\n        float div = f_clk / (frecuencia * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, TOP / 2);\n        sleep_ms(duracion);\n        pwm_set_chan_level(slice, chan, 0);\n    }\n    sleep_ms(30); // Peque\u00f1a pausa entre notas\n}\n\nvoid tocar_silencio(int duracion) {\n    sleep_ms(duracion);\n}\n\nvoid tocar_melodia(uint slice, uint chan) {\n\n\n    // MI MI MI\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, MI, 600);\n\n    tocar_silencio(150);\n\n    // MI MI MI\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, MI, 600);\n\n    tocar_silencio(150);\n\n    // MI SOLs DOs RE MI\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, SOLs, 300);\n    tocar_nota(slice, chan, DOs, 300);\n    tocar_nota(slice, chan, RE, 300);\n    tocar_nota(slice, chan, MI, 600);\n\n    tocar_silencio(300);\n\n    // RE RE RE RE RE MI RE\n    tocar_nota(slice, chan, RE, 300);\n    tocar_nota(slice, chan, RE, 300);\n    tocar_nota(slice, chan, RE, 300);\n    tocar_nota(slice, chan, RE, 300);\n    tocar_nota(slice, chan, RE, 300);\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, RE, 600);\n\n    tocar_silencio(300);\n\n    // MI MI MI MI MI SOLs RE\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, SOLs, 300);\n    tocar_nota(slice, chan, RE, 600);\n\n    tocar_silencio(600); // Pausa larga antes de repetir\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(BUZZER_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(BUZZER_PIN);\n    uint chan  = pwm_gpio_to_channel(BUZZER_PIN);\n\n    pwm_set_wrap(slice, TOP);\n    pwm_set_chan_level(slice, chan, TOP / 2);\n    pwm_set_enabled(slice, true);\n\n    while (true) {\n        tocar_melodia(slice, chan);\n        sleep_ms(2000); // Pausa larga antes de repetir\n    }\n}\n</code></pre> <p></p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_7/#tarea-73","title":"Tarea 7.3","text":"<p>Generar una se\u00f1al sinusoidal aproximada de 60 Hz variando el duty cycle del PWM seg\u00fan una funci\u00f3n seno.</p> <p>Construir un filtro RC pasabajos b\u00e1sico y verificar la se\u00f1al en el osciloscopio:</p> <p>Documentar:</p> <ul> <li>Capturas de osciloscopio Antes del filtro (PWM) y Despu\u00e9s del filtro.</li> </ul> <p>El filtro RC se dise\u00f1a para dejar pasar se\u00f1ales de 60 Hz y eliminar las componentes de alta frecuencia que provienen del PWM.</p> <p>La frecuencia de corte (fcf_cfc\u200b) es el punto donde el filtro empieza a atenuar las se\u00f1ales. Matem\u00e1ticamente:</p> <p>En este caso, queremos que fc sea un poco mayor que 60 Hz para que nuestra se\u00f1al sinusoidal de 60 Hz no sea atenuada.</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_7/#senal-pre-filtro","title":"Se\u00f1al pre filtro","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_7/#senal-filtrada","title":"Se\u00f1al filtrada","text":"<p><pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;math.h&gt;\n\n#define PWM_PIN 18\n#define F_PWM_HZ 2000   // Frecuencia PWM alta para filtrar luego\n#define TOP 1023        // Resoluci\u00f3n 10 bits\n#define F_SIGNAL 60     // Frecuencia de la se\u00f1al sinusoidal (Hz)\n#define SAMPLES 100     // Cantidad de pasos por ciclo sinusoidal\n#define PI 3.14159265\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(PWM_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(PWM_PIN);\n    uint chan  = pwm_gpio_to_channel(PWM_PIN);\n\n    // Calcular divisor para la frecuencia PWM\n    float f_clk = 125000000.0f; // 125 MHz\n    float div = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n    pwm_set_chan_level(slice, chan, 0);\n    pwm_set_enabled(slice, true);\n\n    int sample_index = 0;\n\n    while (true) {\n        // Duty cycle siguiendo un seno: 0..TOP\n        float angle = 2 * PI * sample_index / SAMPLES;\n        int duty = (int)((TOP / 2.0) + (TOP / 2.0) * sin(angle));\n\n        pwm_set_chan_level(slice, chan, duty);\n\n        sample_index = (sample_index + 1) % SAMPLES;\n\n        // Espera entre muestras para que la se\u00f1al tenga 60 Hz\n        sleep_us(1000000 / (F_SIGNAL * SAMPLES));\n    }\n\n    return 0;\n}\n</code></pre> </p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_8/","title":"Tarea 8","text":"<p>1 - Por medio de comunicaci\u00f3n entre dos Pico 2 , lograr accionar leds con botones. 2 - Por medio de la consola lograr prender leds conectados a las Pico 2. 3 - Elaborar un Hanshake.</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_8/#codigo-1-echo","title":"C\u00f3digo 1 (echo)","text":"<pre><code>#include \"pico/stdlib.h\"\n#include &lt;stdio.h&gt;\n\n#define UART_ID uart1\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n\n\n\nint main() {\n    stdio_init_all();\n\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n\n    sleep_ms(2000); // tiempo para enumeraci\u00f3n USB\n\n    while (getchar_timeout_us(0) != PICO_ERROR_TIMEOUT) {\n    // solo leer y descartar cualquier car\u00e1cter residual\n}\n\n    printf(\"\\n[Pico USB] Conexi\u00f3n lista. Escribe algo y Enter.\\n\");\n\n    while (true) {\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            printf(\"Eco: %c\\n\", (char)ch);\n            uart_putc(UART_ID, (char)ch); \n        }\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_8/#codigo-2-envia-y-recibe","title":"C\u00f3digo 2 (envia y recibe)","text":"<pre><code>#include \"pico/stdlib.h\"\n#include &lt;stdio.h&gt;\n\n#define UART_ID uart1\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n\n\n\nint main() {\n    stdio_init_all();\n\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n\n    sleep_ms(2000); // tiempo para enumeraci\u00f3n USB\n\n    while (getchar_timeout_us(0) != PICO_ERROR_TIMEOUT) {\n    // solo leer y descartar cualquier car\u00e1cter residual\n}\n\n    printf(\"\\n[Pico USB] Conexi\u00f3n lista. Escribe algo y Enter.\\n\");\n\n    while (true) {\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            printf(\"Eco: %c\\n\", (char)ch);\n            uart_putc(UART_ID, (char)ch); \n        }\n\n        if (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            printf(\"%c\", c);\n\n        }\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_8/#prendido-de-leds-por-medio-de-boton-fisico","title":"Prendido de leds por medio de boton f\u00edsico","text":"<pre><code>#include \"pico/stdlib.h\"\n#include &lt;stdio.h&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define BTN 3\n#define LED 2\n\n\n\nint main() {\n\n\n    stdio_init_all();\n\n\n    gpio_init(LED);\n    gpio_set_dir(LED, true);\n\n    gpio_init(BTN);\n    gpio_set_dir(BTN, false);\n    gpio_pull_up(BTN);\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n\n    sleep_ms(2000); // tiempo para enumeraci\u00f3n USB\n\n    while (getchar_timeout_us(0) != PICO_ERROR_TIMEOUT) {\n    // solo leer y descartar cualquier car\u00e1cter residual\n}\n\n    printf(\"\\n[Pico USB] Conexi\u00f3n lista. Escribe algo y Enter.\\n\");\n\n    while (true) {\n\n        if (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            printf(\"%c\", c);\n\n            if (c == '1') {\n                gpio_put(LED, 1);  \n                printf(\"LED encendido!\\n\");\n            } \n\n            else {\n                gpio_put(LED, 0);  \n\n            }\n         }\n\n        bool pressed = !gpio_get(BTN);  \n        if (pressed) {\n            printf(\"Bot\u00f3n presionado!\\n\");\n            uart_putc(UART_ID, '1');\n            sleep_ms(300); \n\n\n        }\n         sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_8/#prendido-de-leds-por-medio-de-consola","title":"Prendido de leds por medio de consola","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nint main() {\n    stdio_init_all(); // Inicializa USB serial\n    sleep_ms(2000);\n\n    printf(\"\\n[Pico listo] Comunicaci\u00f3n UART iniciando...\\n\");\n\n    // Inicializa UART antes de asignar pines\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    // Configuraci\u00f3n del LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    string mensaje_usb = \"\";\n    string mensaje_uart = \"\";\n\n    while (true) {\n        //Escritura mensaje\n        int ch = getchar_timeout_us(0); // no bloqueante\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!mensaje_usb.empty()) {\n                    uart_puts(UART_ID, (mensaje_usb + \"\\n\").c_str());\n                    printf(\"Mensaje enviado: %s\\n\", mensaje_usb.c_str());\n                    mensaje_usb = \"\";\n                }\n            } else {\n                mensaje_usb += (char)ch;\n            }\n        }\n\n        //Lectura en UART\n        while (uart_is_readable(UART_ID)) {\n            char ch_uart = uart_getc(UART_ID);\n\n            if (ch_uart == '\\n' || ch_uart == '\\r') {\n                if (!mensaje_uart.empty()) {\n                    printf(\"Mensaje recibido: %s\\n\", mensaje_uart.c_str());\n\n                    // Comparar informaci\u00f3n\n                    if (mensaje_uart == \"on\" || mensaje_uart == \"ON\") {\n                        gpio_put(LED_PIN, 1);\n                        printf(\"LED encendido\\n\");\n                    } else if (mensaje_uart == \"off\" || mensaje_uart == \"OFF\") {\n                        gpio_put(LED_PIN, 0);\n                        printf(\"LED apagado\\n\");\n                    } else {\n                        printf(\"Comando desconocido.\\n\");\n                    }\n\n                    mensaje_uart = \"\";\n                }\n            } else {\n                mensaje_uart += ch_uart;\n            }\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_8/#handshake","title":"Handshake","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_8/#codigo-maestro","title":"C\u00f3digo maestro","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nint main() {\n    stdio_init_all();\n    sleep_ms(2000);\n\n    printf(\"\\n[Pico A listo] Escribe 'conectar' para iniciar handshake.\\n\");\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    string usb_msg = \"\";\n    string uart_msg = \"\";\n    bool conectado = false;\n\n    while (true) {\n        // Leer comandos desde USB\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!usb_msg.empty()) {\n                    uart_puts(UART_ID, (usb_msg + \"\\n\").c_str());\n                    printf(\"[Enviado por UART]: %s\\n\", usb_msg.c_str());\n                    usb_msg = \"\";\n                }\n            } else usb_msg += (char)ch;\n        }\n\n        // Leer mensajes por UART\n        while (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            if (c == '\\n' || c == '\\r') {\n                if (!uart_msg.empty()) {\n                    printf(\"[Recibido]: %s\\n\", uart_msg.c_str());\n\n                    if (!conectado) {\n                        if (uart_msg == \"ok\") {\n                            printf(\"Pico B respondi\u00f3 OK.\\n\");\n                        } else if (uart_msg == \"conectado\") {\n                            printf(\"Conexi\u00f3n establecida \\n\");\n                            conectado = true;\n                        } else {\n                            printf(\"[Error] Mensaje inesperado durante handshake.\\n\");\n                        }\n                    } else {\n                        if (uart_msg == \"on\" || uart_msg == \"ON\") {\n                            gpio_put(LED_PIN, 1);\n                            printf(\"[LED] Encendido (por comando remoto)\\n\");\n                        } else if (uart_msg == \"off\" || uart_msg == \"OFF\") {\n                            gpio_put(LED_PIN, 0);\n                            printf(\"[LED] Apagado (por comando remoto)\\n\");\n                        } else {\n                            printf(\"Error: Comando desconocido tras conexi\u00f3n.\\n\");\n                        }\n                    }\n                    uart_msg = \"\";\n                }\n            } else uart_msg += c;\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_8/#codigo-esclavo","title":"C\u00f3digo esclavo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nint main() {\n    stdio_init_all();\n    sleep_ms(2000);\n\n    printf(\"\\nPico B listo, Esperando handshake desde el otro dispositivo...\\n\");\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    string uart_msg = \"\";\n    string usb_msg = \"\";\n    bool conectado = false;\n\n    while (true) {\n        // Leer mensajes entrantes por UART\n        while (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            if (c == '\\n' || c == '\\r') {\n                if (!uart_msg.empty()) {\n                    printf(\"Recibido: %s\\n\", uart_msg.c_str());\n\n                    if (!conectado) {\n                        if (uart_msg == \"conectar\") {\n                            uart_puts(UART_ID, \"ok\\n\");\n                            sleep_ms(300);\n                            uart_puts(UART_ID, \"conectado\\n\");\n                            conectado = true;\n                            printf(\"Conexi\u00f3n establecida\\n\");\n                        } else {\n                            uart_puts(UART_ID, \"error\\n\");\n                            printf(\"Error, mensaje inesperado durante handshake.\\n\");\n                        }\n                    } else {\n                        if (uart_msg == \"on\" || uart_msg == \"ON\") {\n                            gpio_put(LED_PIN, 1);\n                            printf(\"LED encendido\\n\");\n                        } else if (uart_msg == \"off\" || uart_msg == \"OFF\") {\n                            gpio_put(LED_PIN, 0);\n                            printf(\"LED apagado\\n\");\n                        } else {\n                            printf(\"[Error] Comando desconocido tras conexi\u00f3n.\\n\");\n                        }\n                    }\n                    uart_msg = \"\";\n                }\n            } else uart_msg += c;\n        }\n\n\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!usb_msg.empty()) {\n                    uart_puts(UART_ID, (usb_msg + \"\\n\").c_str());\n                    printf(\"[Enviado por UART]: %s\\n\", usb_msg.c_str());\n                    usb_msg = \"\";\n                }\n            } else usb_msg += (char)ch;\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_8/#recomendaciones-importantes","title":"Recomendaciones importantes","text":"<p>En el cmake agergar:</p> <p>target_link_libraries(t\u00edtulo de tu documento         pico_stdlib         hardware_uart//Esto es importante agregar         ) Y mantener esto as\u00ed:</p> <p>pico_enable_stdio_uart(Examen_2 0) pico_enable_stdio_usb(Examen_2 1)</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_9/","title":"Tarea 9.1","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_9/#adc","title":"ADC","text":"<p>ADC son las siglas de Convertidor Anal\u00f3gico-Digital (Analog-to-Digital Converter) en electr\u00f3nica, un circuito que transforma una se\u00f1al anal\u00f3gica del mundo real (como el sonido o la temperatura) en datos digitales que las computadoras pueden procesar.</p> <p>Transforma se\u00f1ales continuas (anal\u00f3gicas) en valores discretos (digitales).Lo cual es esencial para la mayor\u00eda de los sistemas modernos, ya que les permite interpretar y procesar datos del mundo real, que es inherentemente anal\u00f3gico.</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_9/#adc-luxometro","title":"ADC Luxometro","text":"<p>Crear un codigo que me marca la luminosidad de 0-100% usando un LDR.</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_9/#codigo","title":"C\u00f3digo","text":"<pre><code>const int ldrPin = 26;\n\nvoid setup() {\n  Serial.begin(115200);\n}\n\nvoid loop() {\n  int val = analogRead(ldrPin);\n\n  int percent = map(val, 0, 4095, 0, 100);\n\n  Serial.print(\"Luminosidad: \");\n  Serial.print(percent);\n  Serial.println(\"%\");\n\n  delay(500);\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_9/#tarea-92","title":"Tarea 9.2","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_9/#servo-con-adc","title":"Servo con ADC","text":"<p>Crear un codigo para mover un servo usando un potenciometro y un adc que vaya 0-180 grados.</p> <pre><code>#include &lt;Servo.h&gt;\n\nServo servo;\nconst int potPin = 26;  \nconst int servoPin = 15;\n\nvoid setup() {\n  servo.attach(servoPin);\n}\n\nvoid loop() {\n  int val = analogRead(potPin); \n  int angle = map(val, 0, 4095, 0, 180);  \n  servo.write(angle);\n  delay(10);  \n}\n</code></pre> <p></p>"}]}