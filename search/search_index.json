{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Documentaci\u00f3n del Proyecto","text":"<p>Bienvenido \ud83d\udc4b Esta es una plantilla basada en MkDocs + Material for MkDocs para cursos y proyectos.</p>"},{"location":"#empezar-rapido-3-pasos","title":"Empezar r\u00e1pido (3 pasos)","text":"<ol> <li>Edita el nombre del sitio en <code>mkdocs.yml</code>:    ```yaml    site_name: Documentaci\u00f3n del Curso    theme:      name: material</li> </ol>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"Proyecto_de_ingenieria%204/Intro/","title":"Introduccion","text":"<p>Hola, mi nombre es Carlos Guti\u00e9rrez Mart\u00ednez, tengo 19 a\u00f1os y soy estudiante en la Universidad Iberoamericana de Puebla, estudio la carrera de Ingenier\u00eda en Mecatr\u00f3nica y estoy cursando mi quinto semestre.En este apartado estar\u00e9 subiendo el progreso hecho durante mis clases de Proyectos de Ingenier\u00eda 4.</p>"},{"location":"Proyecto_de_ingenieria%204/Intro/#propuesta-proyecto","title":"Propuesta proyecto","text":"<p>La propuesta de mi proyecto a desarrollar este semestre consiste en un dispositivo capaz de medir la intensidad de los rayos UV del entorno en el que se encuentre y con base a eso poder realizar un diagn\u00f3stico de los cuidados necesarios para evitar da\u00f1os en la piel, el producto est\u00e1 centrado principalmente en evitar da\u00f1os o enfermedades potenciales a aquellas personas que cuentan con un tipo de piel sensible, al mismo tiempo busca poder funcionar como un producto que permita mantener un mejor cuidad de piel.</p>"},{"location":"Proyecto_de_ingenieria%204/Intro/#boceto-inicial","title":"Boceto inicial","text":""},{"location":"Proyecto_de_ingenieria%204/Intro/#caracteristicas-que-debe-de-tener-el-producto","title":"Caracteristicas que debe de tener el producto","text":"<ul> <li>Debe de ser capaz de transformar la intensidad de los rayos UV en valores num\u00e9ricos.</li> <li>Tiene que ser capaz de generar una predicci\u00f3n en relaci\u00f3n al tiempo que tardar\u00eda la piel en recibir da\u00f1os.</li> <li>Tiene que tener los datos de los tipos de piel y como la variable de los rayos UV afecta de forma distinta a cada tipo de piel.</li> </ul>"},{"location":"Proyecto_de_ingenieria%204/Semana1/","title":"Semana 1","text":""},{"location":"Proyecto_de_ingenieria%204/Semana1/#nivel-de-madureza-tecnologica-tlr","title":"Nivel de Madureza Tecnol\u00f3gica (TLR)","text":"<p>\u00bfQu\u00e9 es el nivel de Madureza Tecnol\u00f3gica? </p> <p>Es una medida para describir el estado de desarrollo o madurez de una tecnolog\u00eda.</p> <p>No s\u00f3lo se aplica para medir el estado de madurez de una tecnolog\u00eda para su uso en el entorno operativo, sino que tambi\u00e9n se interpreta como la preparaci\u00f3n de un producto o servicio para ser comercializado.</p> <p>Existen 9 distintos niveles de madurez tecnol\u00f3gica.</p> <p>\u00bfPorque es relevante el Nivel de Madurez Tecnol\u00f3gica para este proyecto? </p> <p>Este semestre el objetivo que mi equipo tiene planeado es poder conseguir llevar un proyecto nuevo a TLR4, por lo que para poder lograrlo se tienen que cumplir los siguientes requisitos:</p> <p>-Prototipo a nivel banco de laboratorio, en donde se pueda medir con alg\u00fan grado de seguridad, que dicho prototipo puede ser escalable cuyas ventajas competitivas y comparativas pueden ser medibles.</p> <p>-Los componentes han sido identificados y se busca establecer si dichos componentes cuentan con las capacidades para actuar de manera conjunta.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana1/#syllabus-firmado","title":"Syllabus Firmado","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyecto_de_ingenieria%204/Semana2/","title":"Semana 2","text":"<p>Esta presentaci\u00f3n sobre la evoluci\u00f3n del caf\u00e9 hasta las m\u00e1quinas de c\u00e1psulas, con un enfoque en Nespresso como l\u00edder del mercado.     Analizar c\u00f3mo Nespresso desarroll\u00f3 su tecnolog\u00eda, optimiz\u00f3 sus m\u00e1quinas y estandariz\u00f3 sus c\u00e1psulas nos permite entender c\u00f3mo se aplican conceptos de dise\u00f1o mecatr\u00f3nico, sensores, actuadores y control de procesos en un producto real. Adem\u00e1s, sirve como inspiraci\u00f3n para la creaci\u00f3n de nuestro propio proyecto, mostrando la importancia de llevar un prototipo desde la investigaci\u00f3n y pruebas hasta un sistema confiable y listo para el usuario, aplicando estrategias de innovaci\u00f3n y validaci\u00f3n tecnol\u00f3gica.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana2/#nesspreso","title":"NESSPRESO","text":"<p>\u00bfQu\u00e9 diferencia a NESPRESSO del resto?</p>"},{"location":"Proyecto_de_ingenieria%204/Semana2/#propuestas-a-evaluar-y-las-problematicas-que-resuelven","title":"Propuestas a evaluar y las problematicas que resuelven","text":"<p>A partir del an\u00e1lisis a la compa\u00f1\u00eda NESPRESSO, el equipo realiz\u00f3 un an\u00e1lisis similar para evaluar las propuestas de mi propio proyecto, aplicando los mismos criterios: identificar los requerimientos tecnol\u00f3gicos, dise\u00f1ar prototipos funcionales y validar su desempe\u00f1o. Propuestas finales</p>"},{"location":"Proyecto_de_ingenieria%204/Semana3/","title":"Semana 3","text":"<p>Esta semana elabromas un diagrama de gantt para poder visualizar de manera organizada las tareas que debemos realizar para poder concretar el proyecto, y designar un periodo espec\u00edfico de tiempo a cada tarea, todo con el prop\u00f3sito de agilizar la elaboraci\u00f3n del producto final.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana3/#que-es-un-diagrama-de-gantt","title":"\u00bfQu\u00e9 es un diagrama de Gantt?","text":"<p>Un diagrama de Gantt es en resumidas cuentas un gr\u00e1fico de barras horizontales que muestran la duraci\u00f3n, las fechas de inicio y fin, el progreso y las dependencias entre las tareas; ayuda mucho a la hora de agilizar y organizar proyectos de forma clara.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana3/#diagrama-de-gantt-del-proyecto","title":"Diagrama de Gantt del proyecto","text":"<p>Para el diagrama de Gantt nuestro equipo utiliz\u00f3 una plataforma llamada JIRA, la cual est\u00e1 especializada en diagramas para proyectos, la plataforma es sumamente sencilla de usar y permite asignar fechas, delegar tareas o actividades a diferentes miembros de equipo, y asignar un nivel de prioridad a cada tarea.</p> <ul> <li>Paso 1: A\u00f1adimos las tareas u objetivos principales, aquellos que son esenciales que cumplamos para poder terminar un producto exitoso.</li> </ul> <p></p> <ul> <li>Paso 2: Colocamos sub-objetivos que permitan monitorear de forma m\u00e1s espec\u00edfica los avances requeridos, de esta forma se puede dividir el trabajo de forma m\u00e1s eficiente.</li> </ul> <p></p> <ul> <li>Paso 3: Teniendo todo lo anterior solo nos movemos a la barra de nombre \"cronograma\" y podemos visualizar nuestro diagrama de Gantt ya finalizado, el cual ayudar\u00e1 a poder organizar nuestras tareas de forma limpia.</li> </ul> <p></p> <p>Enlace para visualizar el diagrama de Gantt</p>"},{"location":"Proyecto_de_ingenieria%204/Semana4/","title":"Semana 4","text":""},{"location":"Proyecto_de_ingenieria%204/Semana4/#que-es-un-marco-real-ganar-vale-la-pena","title":"\u00bfQu\u00e9 es un marco \"Real-Ganar-Vale la pena\"","text":"<p>Un Marco \"real-ganar-vale la pena\" (Real-Win-Worth it o RGW) es una herramienta de evaluaci\u00f3n desarrollada por 3M para analizar la viabilidad de una idea o producto en tres frentes: que sea real, que se pueda ganar y que valga la pena. Este m\u00e9todo ayuda a las empresas a filtrar y seleccionar las ideas m\u00e1s prometedoras para el desarrollo, asegurando que la idea sea viable en el mercado y que pueda generar beneficios. </p>"},{"location":"Proyecto_de_ingenieria%204/Semana4/#que-criterios-evalua","title":"\u00bfQu\u00e9 criterios eval\u00faa?","text":"<ol> <li> <p>Real (\u00bfEs Real?): Se eval\u00faa la viabilidad t\u00e9cnica y de mercado del producto. La pregunta clave es si la tecnolog\u00eda existe o puede desarrollarse y si el producto tiene demanda en el mercado.</p> </li> <li> <p>Ganar (\u00bfSe Puede Ganar?): Se analiza la capacidad de la empresa para competir y tener \u00e9xito en el mercado. Esto implica considerar la posici\u00f3n de la empresa, sus recursos y la competencia.</p> </li> <li> <p>Vale la pena (\u00bfVale la pena?): Se determina si la inversi\u00f3n en el producto es rentable y justificar\u00e1 el esfuerzo. La empresa debe considerar los beneficios esperados frente a los costos y riesgos asociados.</p> </li> </ol> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyecto_de_ingenieria%204/Semana5/","title":"Semana 5","text":""},{"location":"Proyecto_de_ingenieria%204/Semana5/#objetivo","title":"Objetivo","text":"<ul> <li>Definir qui\u00e9n es el cliente de tu proyecto y el tama\u00f1o de ese mercado.</li> <li>Realizar el an\u00e1lisis de las 5 fuerzas de Porter.</li> <li>Hacer la propuesta de valor de su proyecto con la tabla Creando Valor.</li> </ul> <p>Definir qui\u00e9n es el cliente de un proyecto y conocer el tama\u00f1o de su mercado es fundamental porque permite orientar los esfuerzos de dise\u00f1o, producci\u00f3n y comunicaci\u00f3n hacia las personas que realmente necesitan y valoran la soluci\u00f3n. Si se identifica claramente al cliente, se pueden entender mejor sus necesidades, problemas y motivaciones, lo que facilita crear un producto o servicio m\u00e1s relevante y competitivo. Al mismo tiempo, estimar el tama\u00f1o del mercado ayuda a dimensionar la oportunidad: permite saber si existe una demanda suficiente que justifique la inversi\u00f3n, planear estrategias de crecimiento y anticipar la viabilidad econ\u00f3mica del proyecto. En conjunto, estos elementos son la base para que el proyecto tenga un impacto real y sostenible.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana5/#analisis-de-mercado","title":"An\u00e1lisis de mercado","text":"<p>El an\u00e1lisis de mercado es importante porque permite entender las necesidades, preferencias y comportamientos de los posibles usuarios, as\u00ed como identificar la competencia y las oportunidades existentes. Gracias a este estudio, podemos definir mejor el p\u00fablico objetivo, ajustar el dise\u00f1o y precio del producto y tomar decisiones m\u00e1s acertadas que aumenten las posibilidades de \u00e9xito y aceptaci\u00f3n del proyecto en el mercado real.</p> <p>An\u00e1lisis de mercado</p>"},{"location":"Proyecto_de_ingenieria%204/Semana5/#cuadro-de-valor","title":"Cuadro de Valor","text":"<p>El cuadro de valor  es fundamental porque permite comparar nuestro producto con las alternativas existentes, destacando los aspectos que lo hacen \u00fanico o m\u00e1s beneficioso para el usuario. A trav\u00e9s de este an\u00e1lisis, podemos identificar fortalezas, debilidades y oportunidades de mejora, adem\u00e1s de comunicar con claridad el valor que aporta nuestro proyecto, tanto en funcionalidad como en costo y accesibilidad.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana5/#analisis-de-las-5-fuerzas-de-porter","title":"An\u00e1lisis de las 5 fuerzas de Porter","text":"<p>El an\u00e1lisis de las 5 fuerzas de Porter es una herramienta estrat\u00e9gica que sirve para evaluar la competitividad de una industria o sector. Fue desarrollada por Michael Porter y busca entender qu\u00e9 tan atractivo o rentable puede ser un mercado, analizando los factores externos que influyen en \u00e9l.</p> <p>Las cinco fuerzas son:</p> <ul> <li> <p>Rivalidad entre competidores existentes: mide el nivel de competencia directa en el mercado (n\u00famero de competidores, precios, diferenciaci\u00f3n de productos).</p> </li> <li> <p>Amenaza de nuevos entrantes: eval\u00faa qu\u00e9 tan f\u00e1cil o dif\u00edcil es para nuevas empresas entrar en la industria y competir.</p> </li> <li> <p>Poder de negociaci\u00f3n de los proveedores: analiza la influencia que tienen los proveedores sobre los costos y la disponibilidad de insumos.</p> </li> <li> <p>Poder de negociaci\u00f3n de los clientes: examina qu\u00e9 tanto poder tienen los consumidores para exigir precios bajos, mayor calidad o mejores condiciones.</p> </li> <li> <p>Amenaza de productos sustitutos: identifica si existen alternativas que puedan reemplazar la soluci\u00f3n que ofrece el producto o servicio.</p> </li> </ul>"},{"location":"Proyecto_de_ingenieria%204/Semana6/","title":"Semana 6","text":""},{"location":"Proyecto_de_ingenieria%204/Semana6/#tarjetas-de-trabajo","title":"Tarjetas de trabajo","text":"<p>Esta semana creamos un \u00e1rea de trabajo personalizable, para poder asignar trabajos, tareas, objetivos y recursos de manera organizada en un espacion online compartido con todo el equipo.</p> <p>Para esto utilizamos la aplicaci\u00f3n TRELLO, la cual nos permite hacer todo lo anterior de forma sencillas y simple.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana6/#ventajas-al-usar-trello","title":"Ventajas al usar TRELLO","text":"<ol> <li> <p>Visualizar el progreso:Las tarjetas se mueven entre columnas tipo \u201cPor hacer \u2192 En proceso \u2192 Hecho\u201d, lo que te permite ver el avance del proyecto de un vistazo.Es muy \u00fatil para detectar bloqueos (por ejemplo, tareas que llevan demasiado tiempo en \u201cEn proceso\u201d).</p> </li> <li> <p>Gesti\u00f3n de tiempo y prioridades:Puedes poner fechas l\u00edmite o etiquetas (\u201cAlta prioridad\u201d, \u201cInvestigaci\u00f3n\u201d, \u201cDise\u00f1o\u201d) y as\u00ed concentrarte en lo m\u00e1s urgente o importante.</p> </li> <li> <p>Documentaci\u00f3n del proyecto: Cada tarjeta puede tener notas, enlaces, im\u00e1genes o archivos, as\u00ed que sirve como registro del trabajo.Esto es muy \u00fatil cuando tienes que presentar el proyecto o explicar c\u00f3mo fue evolucionando.</p> </li> </ol>"},{"location":"Proyecto_de_ingenieria%204/Semana6/#costos-de-produccion-costos-de-materiales","title":"Costos de producci\u00f3n (costos de materiales)","text":""},{"location":"Proyecto_de_ingenieria%204/Semana6/#importancia-de-minimizar-costos","title":"Importancia de minimizar costos","text":"<p>Para poder crear el prototipo necesitamos varios materiales, por lo mismo es imperativo encontrar los mejores precios que permitan mantener un costo de producci\u00f3n m\u00ednimo, ayudando as\u00ed tambi\u00e9n a impulsar las ganancias del producto.Debido a lo mencionado nosotros investigamos en diferentes sitios web, desde empresas grandes (Mercado libre, Amazon) a locales peque\u00f1os  (tiendas de electronica locales) para poder encontrar los mejores materiales por el mejor precio, a continuaci\u00f3n incluyo la evidencia de dicha investigaci\u00f3n.</p> <p>Investigaci\u00f3n de costos de arranque.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana6/#ciclos-intentos","title":"Ciclos (intentos)","text":"<p>En la presentaci\u00f3n anterior mencionamos algo llamado \"ciclo\", para aquellos que no entiendan a que se refiere esto, un ciclo es el equivalente a un intento, refieri\u00e9ndonos claro a la elaboraci\u00f3n de alguna parte del prototipo, por lo que ciclo se refiere a cuantos intentos se requiere para poder alcanzar el objetivo deseado.Esta terminolog\u00eda nos permite hacer un an\u00e1lisis realista de cuanto tiempo, esfuerzo o personal requiere cada fase del proyecto, lo que permite distribuir recursos y tiempo de forma m\u00e1s eficiente.</p> <p>Al hacer una an\u00e1lisis de ciclos, el conocimiento emp\u00edrico es sumamente relevante, ya que muchas veces la planeaci\u00f3n y teor\u00eda son mucho m\u00e1s f\u00e1ciles que la pr\u00e1ctica.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana7/","title":"Semana 7","text":"<p>Hicimos una tabla de costos para nuestro prototipo con el objetivo de tener una visi\u00f3n clara y organizada de los recursos necesarios para su desarrollo desde cero. En ella se desglosan tanto los costos de producci\u00f3n \u2014como materiales, componentes electr\u00f3nicos, herramientas y mano de obra\u2014, como los costos de distribuci\u00f3n que se planean adoptar, incluyendo empaque, transporte y posibles canales de venta. Esta tabla nos permite estimar el presupuesto total, evaluar la viabilidad econ\u00f3mica del proyecto y planificar una estrategia de producci\u00f3n sostenible, asegurando que el prototipo no solo sea funcional, sino tambi\u00e9n accesible y realista para su futura implementaci\u00f3n o comercializaci\u00f3n.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana7/#creando-la-oferta","title":"Creando la oferta","text":"<p>Al crear la oferta de nuestro producto, es necesario dividir los costos individuales que se requieren para la producci\u00f3n unitaria de dicha prototipo, de manera que se pueda crear un an\u00e1lisis en relaci\u00f3n a un a\u00f1o (nosotros elegimos un a\u00f1o) de cu\u00e1nto costar\u00eda la producci\u00f3n de una cantidad determinada del producto terminado.</p> <p>En este caso, nosotros separamos nuestros costos de manera que se pueda identificar, cu\u00e1les son aquellos que diferencian a nuestro producto de los dem\u00e1s.</p>"},{"location":"Proyecto_de_ingenieria%204/Semana7/#dsitribucion-del-producto","title":"Dsitribuci\u00f3n del producto","text":"<p>La distribuci\u00f3n del producto es ESENCIAL para la creaci\u00f3n y venta de una idea, ya que se tiene que considerar \u00bfa qui\u00e9n? y \u00bfc\u00f3mo? vas a hacer llegar tu idea.</p> <p>A continuaci\u00f3n adjunto nuestro excel.</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Primer_examen/","title":"Primer examen parcial","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Primer_examen/#objetivo","title":"Objetivo","text":"<p>Construir un juego Sim\u00f3n Dice de 4 colores en Raspberry Pi Pico 2.</p> <ul> <li>La secuencia crece +1 por ronda, de 1 hasta 15.</li> <li>La persona jugadora debe repetir la secuencia con 4 botones dentro de un tiempo l\u00edmite por ronda.</li> <li>Tiempo l\u00edmite por ronda (fase de entrada): TL = longitud + 5 segundos (p. ej., Ronda 7 \u2192 12 s).</li> <li>Puntaje (0\u201315): mostrar la m\u00e1xima ronda alcanzada en un display de 7 segmentos en hex (0\u20139, A, b, C, d, E, F).</li> <li>Aleatoriedad obligatoria: la secuencia debe ser impredecible en cada ejecuci\u00f3n.</li> </ul>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Primer_examen/#condiciones","title":"Condiciones","text":"<ol> <li>Encendido/Reset: el 7 segmentos muestra \u201c0\u201d y queda en espera de Start (cualquier bot\u00f3n permite iniciar).</li> <li>Reproducci\u00f3n:: mostrar la secuencia actual (LEDs uno por uno con separaci\u00f3n clara).</li> <li>Entrada: al terminar la reproducci\u00f3n, la persona debe repetir la secuencia completa dentro de TL.</li> <li>Fallo (Game Over): bot\u00f3n incorrecto, falta/extra de entradas o exceder TL.</li> <li>Progresi\u00f3n: si acierta, puntaje = n\u00famero de ronda, agrega 1 color aleatorio y avanza.</li> <li>Fin: al fallar o completar la Ronda 15. Mostrar puntaje final en 7 segmentos (hex).</li> </ol> <pre><code>#include \"pico/stdlib.h\" // Librer\u00eda b\u00e1sica de Raspberry Pi Pico (GPIO, sleep, etc.)\n#include &lt;stdlib.h&gt;      // Para rand() y srand()\n#include &lt;time.h&gt;        // Para obtener tiempo y usarlo como semilla aleatoria\n\n// --- Pines de LEDs y botones ---\nconst uint LED_PINS[4] = {0, 1, 2, 3};       // Pines GPIO donde est\u00e1n conectados los LEDs\nconst uint BUTTON_PINS[4] = {4, 5, 6, 7};    // Pines GPIO donde est\u00e1n conectados los botones\n\n// --- Pines de display de 7 segmentos (\u00e1nodo com\u00fan) ---\nconst uint SEG_PINS[7] = {13, 12, 18, 17, 16, 14, 15}; // Pines de segmentos a-g\n\n// --- Constantes de juego ---\n#define MAX_ROUNDS 15      // N\u00famero m\u00e1ximo de rondas\n#define LED_ON_TIME 400    // Tiempo en ms que un LED permanece encendido\n#define LED_OFF_TIME 200   // Tiempo en ms que un LED permanece apagado entre flashes\n\nint sequence[MAX_ROUNDS];  // Array donde se guarda la secuencia de LEDs de cada ronda\n\n// --- Segmentos por nombre para mayor claridad ---\n#define SEG_A 0\n#define SEG_B 1\n#define SEG_C 2\n#define SEG_D 3\n#define SEG_E 4\n#define SEG_F 5\n#define SEG_G 6\n\n// --- Definici\u00f3n de n\u00fameros seg\u00fan qu\u00e9 segmentos se encienden (0-F) ---\nconst uint8_t NUM_SEGMENTS[16][7] = {\n    {SEG_A, SEG_B, SEG_C, SEG_D, SEG_E, SEG_F, 255},   // 0\n    {SEG_B, SEG_C, 255, 255, 255, 255, 255},           // 1\n    {SEG_A, SEG_B, SEG_D, SEG_E, SEG_G, 255, 255},     // 2\n    {SEG_A, SEG_B, SEG_C, SEG_D, SEG_G, 255, 255},     // 3\n    {SEG_B, SEG_C, SEG_F, SEG_G, 255, 255, 255},       // 4\n    {SEG_A, SEG_C, SEG_D, SEG_F, SEG_G, 255, 255},     // 5\n    {SEG_A, SEG_C, SEG_D, SEG_E, SEG_F, SEG_G, 255},   // 6\n    {SEG_A, SEG_B, SEG_C, 255, 255, 255, 255},         // 7\n    {SEG_A, SEG_B, SEG_C, SEG_D, SEG_E, SEG_F, SEG_G}, // 8\n    {SEG_A, SEG_B, SEG_C, SEG_D, SEG_F, SEG_G, 255},   // 9\n    {SEG_A, SEG_B, SEG_C, SEG_E, SEG_F, SEG_G, 255},   // A\n    {SEG_C, SEG_D, SEG_E, SEG_F, SEG_G, 255, 255},     // B\n    {SEG_A, SEG_D, SEG_E, SEG_F, 255, 255, 255},       // C\n    {SEG_B, SEG_C, SEG_D, SEG_E, SEG_G, 255, 255},     // D\n    {SEG_A, SEG_D, SEG_E, SEG_F, SEG_G, 255, 255},     // E\n    {SEG_A, SEG_E, SEG_F, SEG_G, 255, 255, 255}        // F\n};\n\n// --- Inicializaci\u00f3n de hardware ---\nvoid init_hardware() {\n    // Configura LEDs y botones\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(LED_PINS[i]);           // Inicializa pin LED\n        gpio_set_dir(LED_PINS[i], true);  // Lo pone como salida\n        gpio_put(LED_PINS[i], 0);         // Lo apaga inicialmente\n\n        gpio_init(BUTTON_PINS[i]);        // Inicializa pin de bot\u00f3n\n        gpio_set_dir(BUTTON_PINS[i], false); // Lo pone como entrada\n        gpio_pull_up(BUTTON_PINS[i]);     // Activa pull-up interno para leer 1 cuando no se presiona\n    }\n\n    // Configura display de 7 segmentos\n    for (int i = 0; i &lt; 7; i++) {\n        gpio_init(SEG_PINS[i]);           // Inicializa pin de segmento\n        gpio_set_dir(SEG_PINS[i], true);  // Salida\n        gpio_put(SEG_PINS[i], 1);         // Apaga todos los segmentos inicialmente (\u00e1nodo com\u00fan)\n    }\n}\n\n// --- Enciende un LED por un tiempo y lo apaga ---\nvoid blink_led(int led_index) {\n    gpio_put(LED_PINS[led_index], 1);   // Enciende LED\n    sleep_ms(LED_ON_TIME);               // Espera tiempo definido\n    gpio_put(LED_PINS[led_index], 0);   // Apaga LED\n    sleep_ms(LED_OFF_TIME);              // Espera tiempo definido antes del siguiente LED\n}\n\n// --- Muestra un n\u00famero en el display de 7 segmentos ---\nvoid display_number_inverted(uint8_t num) {\n    if (num &gt; 15) return;                // Solo n\u00fameros 0-F\n    for (int i = 0; i &lt; 7; i++) gpio_put(SEG_PINS[i], 1); // Apaga todos los segmentos\n    for (int j = 0; j &lt; 7; j++) {\n        if (NUM_SEGMENTS[num][j] == 255) break;           // Fin de segmentos para ese n\u00famero\n        gpio_put(SEG_PINS[NUM_SEGMENTS[num][j]], 0);     // Enciende segmento correspondiente\n    }\n}\n\n// --- Espera a que se presione cualquier bot\u00f3n ---\nvoid wait_any_button() {\n    while (true) {\n        for (int i = 0; i &lt; 4; i++) {\n            if (!gpio_get(BUTTON_PINS[i])) { // Si se presiona\n                sleep_ms(50);               // Debounce inicial\n                while (!gpio_get(BUTTON_PINS[i])); // Espera a soltar\n                sleep_ms(50);               // Debounce final\n                return;                     // Sale de la funci\u00f3n\n            }\n        }\n    }\n}\n\n// --- Lee qu\u00e9 bot\u00f3n se presiona con timeout ---\nint read_button_timeout(int timeout_seconds) {\n    absolute_time_t end_time = make_timeout_time_ms(timeout_seconds * 1000); // Calcula momento final\n    while (absolute_time_diff_us(get_absolute_time(), end_time) &gt; 0) {      // Mientras no se acabe el tiempo\n        for (int i = 0; i &lt; 4; i++) {\n            if (!gpio_get(BUTTON_PINS[i])) { // Si se presiona bot\u00f3n\n                sleep_ms(50);                // Debounce\n                while (!gpio_get(BUTTON_PINS[i])); // Espera a soltar\n                sleep_ms(50);                // Debounce final\n                return i;                    // Devuelve \u00edndice del bot\u00f3n presionado\n            }\n        }\n    }\n    return -1; // Timeout, no se presion\u00f3 ning\u00fan bot\u00f3n\n}\n\n// --- Parpadea la ronda actual en el display ---\nvoid flash_round(uint8_t round_num, int times, int ms_delay) {\n    for (int i = 0; i &lt; times; i++) {\n        display_number_inverted(round_num);        // Muestra n\u00famero\n        sleep_ms(ms_delay);                        // Espera\n        for (int k = 0; k &lt; 7; k++) gpio_put(SEG_PINS[k], 1); // Apaga todos los segmentos\n        sleep_ms(ms_delay);                        // Espera antes del siguiente parpadeo\n    }\n}\n\n// --- Parpadea LEDs y muestra n\u00famero si el jugador falla ---\nvoid flash_error(int failed_round) {\n    display_number_inverted(failed_round);         // Muestra ronda donde fall\u00f3\n    for (int i = 0; i &lt; 3; i++) {                 // Parpadea 3 veces\n        for (int j = 0; j &lt; 4; j++) gpio_put(LED_PINS[j], 1); // Enciende todos los LEDs\n        sleep_ms(300);                             // Espera 300 ms\n        for (int j = 0; j &lt; 4; j++) gpio_put(LED_PINS[j], 0); // Apaga todos los LEDs\n        sleep_ms(300);                             // Espera 300 ms\n    }\n}\n\n// --- Funci\u00f3n principal ---\nint main() {\n    stdio_init_all();    // Inicializa la comunicaci\u00f3n serial (opcional)\n    init_hardware();     // Inicializa LEDs, botones y display\n\n    while (true) {       // Bucle infinito del juego\n        wait_any_button();                        // Espera a que el jugador presione un bot\u00f3n para iniciar\n        srand(to_us_since_boot(get_absolute_time())); // Inicializa semilla aleatoria con tiempo\n\n        int round = 0;                            // Empieza en ronda 0\n        bool game_over = false;\n\n        while (!game_over &amp;&amp; round &lt; MAX_ROUNDS) { // Mientras no haya terminado el juego\n            sequence[round] = rand() % 4;         // Genera LED aleatorio para la ronda\n\n            display_number_inverted(round + 1);   // Muestra n\u00famero de ronda\n\n            for (int i = 0; i &lt;= round; i++) blink_led(sequence[i]); // Reproduce secuencia de LEDs\n\n            for (int i = 0; i &lt;= round; i++) {   // Jugador intenta repetir la secuencia\n                int btn = read_button_timeout(5 + round); // Tiempo de respuesta aumenta con la ronda\n                if (btn == -1 || btn != sequence[i]) {    // Si falla o timeout\n                    game_over = true;\n                    flash_error(round + 1);              // Feedback visual de error\n                    break;\n                }\n                blink_led(btn);                           // Feedback visual si presiona correcto\n            }\n\n            if (!game_over) {                              // Si acierta, pasa a la siguiente ronda\n                round++;\n                if (round &lt; MAX_ROUNDS) flash_round(round + 1, 2, 300); // Parpadea n\u00famero de la siguiente ronda\n            }\n        }\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Segundo_examen/","title":"Segundo examen parcial","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0 \n#define UART_RX_PIN 1\n\n#define SERVO_PIN 2\nconst uint BTN1 = 4; // Botones del modo step\nconst uint BTN2 = 5;\nconst uint BTN3 = 3; // Bot\u00f3n para cambiar entre modos\n\nusing namespace std;\n\n// Lista global donde se guardan las posiciones del servo, con esto podemos usar la lista en cualquier funci\u00f3n\nint valores_guardados[3] = {0, 0, 0};\n\n// Variables compartidas entre el programa principal y la interrupci\u00f3n\nvolatile int modo_actual = 1;     // 1: write, 2: continuo, 3: step\nvolatile bool ciclo_activo = false;\n\n//Funci\u00f3n: borrar la lista de valores\nvoid borrar_lista() {\n    for (int i = 0; i &lt; 3; i++) valores_guardados[i] = 0;\n    printf(\"Lista borrada.\\n\");\n}\n\n//convertir un \u00e1ngulo (0\u2013180) a un valor de PWM \nuint16_t angle_to_level(uint16_t angle) {\n    // Convierte un \u00e1ngulo en microsegundos para el pulso del servo\n    float pulse_us = 1000.0f + (angle * 1000.0f / 180.0f);\n    // Convierte el tiempo a un nivel proporcional al periodo \n    return (uint16_t)((pulse_us / 20000.0f) * 65535);\n}\n\n//interrupci\u00f3n, sirve para cambiar entre los modos 1, 2 y 3\nvoid cambiar_modo(uint gpio, uint32_t events) {\n    if (gpio == BTN3) {\n        modo_actual++;\n        if (modo_actual &gt; 3) modo_actual = 1; // Regresa a modo 1 si pasa del 3\n        ciclo_activo = (modo_actual == 2);    // El modo continuo activa un ciclo\n        printf(\"\\nAhora est\u00e1s en el modo %d\\n\", modo_actual);\n    }\n}\n\nint main() {\n    stdio_init_all();\n    sleep_ms(2000);\n\n    printf(\"Bienvenido, actualmente te encuentras en el modo de entrenamiento, presiona el boton para moverte a otro modo\\n\");\n    printf(\"En este modo puedes escribir(write), remplazar(replace), y borrar(clear) 3 posiciones del servo\\n\");\n    printf(\"Escribe alguno de los comandos para hacer alguna accion\\n\");\n\n    //iniciar UART(comunicaci\u00f3n serial entre Pico y PC)\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    //iniciar PWM para controlar el servo\n    gpio_set_function(SERVO_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(SERVO_PIN);   // Cada pin PWM pertenece a un \"slice\"\n    uint chan  = pwm_gpio_to_channel(SERVO_PIN);     // Canal A o B\n    pwm_set_wrap(slice, 65535);                      // Valor m\u00e1ximo del contador PWM\n    float f_clk = 125000000.0f;                      // Frecuencia base del reloj (125 MHz)\n    float div = f_clk / (50.0f * 65536.0f);          // Calcula divisor para 50Hz (servo)\n    pwm_set_clkdiv(slice, div);\n    pwm_set_enabled(slice, true);\n\n    // --- Configurar los botones ---\n    gpio_init(BTN1); gpio_set_dir(BTN1, GPIO_IN); gpio_pull_up(BTN1);\n    gpio_init(BTN2); gpio_set_dir(BTN2, GPIO_IN); gpio_pull_up(BTN2);\n    gpio_init(BTN3); gpio_set_dir(BTN3, GPIO_IN); gpio_pull_up(BTN3);\n\n    // habilitar interrupci\u00f3n para BTN3\n    // \"&amp;\" se usa para pasar la direcci\u00f3n de la funci\u00f3n \"cambiar_modo, nos permite cambiar el valor de la variable directamente\"\n    // as\u00ed la Pico sabe qu\u00e9 funci\u00f3n ejecutar cuando se presiona el bot\u00f3n\n    gpio_set_irq_enabled_with_callback(BTN3, GPIO_IRQ_EDGE_FALL, true, &amp;cambiar_modo);\n\n    // Variables locales de uso general\n    string mensaje_usb = \"\", mensaje_uart = \"\";\n    int modo_index = 0;      \n    bool btn1_presionado = false, btn2_presionado = false;\n\n    //Bucle principal\n    while (true) {\n\n        // Leer texto que llega desde la consola USB \n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') { // Enter presionado\n                if (!mensaje_usb.empty()) {\n                    string comando = mensaje_usb;\n\n                    // WRITE\n                    if (comando == \"write\" || comando == \"escribir\" || comando == \"Write\" || comando == \"Escribir\") {\n                        printf(\"Ingresa 3 valores separados por comas (ej: 0,90,130):\\n\");\n                        string entrada_valores = \"\";\n                        while (true) {\n                            int c2 = getchar_timeout_us(0);\n                            if (c2 != PICO_ERROR_TIMEOUT) {\n                                if (c2 == '\\n' || c2 == '\\r') break;\n                                entrada_valores += (char)c2;\n                            }\n                        }\n\n                        // Procesar los valores separados por comas\n                        int i = 0; string temp = \"\"; bool error = false; int num_comas = 0;\n                        for (char c : entrada_valores) {\n                            if (c == ',') {\n                                num_comas++;\n                                if (i &lt; 3) {\n                                    int val = stoi(temp); // convierte un string a n\u00famero entero \"string to integrer\"\n                                    if (val &lt; 0 || val &gt; 180) { error = true; break; }\n                                    valores_guardados[i] = val;\n                                    temp = \"\"; i++;\n                                }\n                            } else temp += c;\n                        }\n                        // \u00daltimo valor despu\u00e9s de la \u00faltima coma\n                        if (!error &amp;&amp; !temp.empty() &amp;&amp; i &lt; 3) {\n                            int val = stoi(temp); \n                            if (val &lt; 0 || val &gt; 180) error = true;\n                            else valores_guardados[i] = val;\n                            i++;\n                        }\n\n                        //Validaciones (errores)\n                        if (error) printf(\"Que paso papito, dije valores de 0 a 180\\n\");\n                        else if (i != 3 || num_comas != 2) printf(\"Ponte pilas, recuerda que son 3 valores\\n\");\n                        else printf(\"Valores guardados: %d, %d, %d\\n\", valores_guardados[0], valores_guardados[1], valores_guardados[2]);\n                    } \n                    //borrado de lista ---\n                    else if (comando == \"clear\" || comando == \"borrar\" || comando == \"Clear\" || comando == \"Borrar\") {\n                        borrar_lista();\n                    }\n                    //reemplazar un valor espec\u00edfico ---\n                    else if (comando == \"replace\" || comando == \"reemplazar\" || comando == \"Replace\" || comando == \"Reemplazar\") {\n                        printf(\"Formato: Replace:posicion,valor (ej: Replace:1,130)\\n\");\n                        string entrada_replace = \"\";\n                        while (true) {\n                            int c2 = getchar_timeout_us(0);\n                            if (c2 != PICO_ERROR_TIMEOUT) {\n                                if (c2 == '\\n' || c2 == '\\r') break;\n                                entrada_replace += (char)c2;\n                            }\n                        }\n\n                        // Separar posici\u00f3n y valor\n                        int pos = -1, val = -1; string temp=\"\"; bool sep=false;\n                        for (char c : entrada_replace) {\n                            if (c == ',' &amp;&amp; !sep) {\n                                pos = stoi(temp)-1; temp=\"\"; sep=true;\n                            } else temp+=c;\n                        }\n                        if (sep &amp;&amp; !temp.empty()) val = stoi(temp);\n\n                        // Validaciones(error)\n                        if (pos&lt;0 || pos&gt;2) printf(\"Error: posici\u00f3n inv\u00e1lida\\n\");\n                        else if (val&lt;0 || val&gt;180) printf(\"Error: valor inv\u00e1lido\\n\");\n                        else {\n                            valores_guardados[pos]=val;\n                            printf(\"Valor reemplazado: pos%d = %d\\n\", pos+1, val);\n                            printf(\"Lista: %d, %d, %d\\n\", valores_guardados[0], valores_guardados[1], valores_guardados[2]);\n                        }\n                    }\n                    mensaje_usb=\"\";\n                }\n            } else mensaje_usb += (char)ch;\n        }\n\n        // STEP \n        bool b1 = gpio_get(BTN1)==0;\n        bool b2 = gpio_get(BTN2)==0; \n        if (modo_actual==3) {\n            if (b1 &amp;&amp; !btn1_presionado) {\n                if (modo_index&gt;0) modo_index--;\n            pwm_set_chan_level(slice, chan, angle_to_level(valores_guardados[modo_index]));\n            printf(\"Servo a %d\u00b0\\n\", valores_guardados[modo_index]);\n                btn1_presionado=true;\n            } else if (!b1) btn1_presionado=false;\n\n            if (b2 &amp;&amp; !btn2_presionado) {\n                if (modo_index&lt;2) modo_index++;\n            pwm_set_chan_level(slice, chan, angle_to_level(valores_guardados[modo_index]));\n                printf(\"Servo a %d\u00b0\\n\", valores_guardados[modo_index]);\n                btn2_presionado=true;\n            } else if (!b2) btn2_presionado=false;\n        }\n\n        // CONTINUO \n        if (modo_actual==2 &amp;&amp; ciclo_activo) {\n            bool vacia = (valores_guardados[0]==0 &amp;&amp; valores_guardados[1]==0 &amp;&amp; valores_guardados[2]==0);\n            if (vacia) {\n                printf(\"Error: no hay lista de valores\\n\");\n                sleep_ms(1500);\n            } else {\n                for (int i=0;i&lt;3;i++) {\n                 pwm_set_chan_level(slice, chan, angle_to_level(valores_guardados[i]));\n                    printf(\"pos%d: %d\\n\", i+1, valores_guardados[i]);\n                    for (int t=0;t&lt;15;t++) { // Espera total de 1.5 segundos\n                        sleep_ms(100);\n                        if (!ciclo_activo) break;  // Si se cambia de modo, salir\n                    }\n                    if (!ciclo_activo) break;\n                }\n            }\n        }\n\n        sleep_ms(10); \n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_1/","title":"Tarea 1","text":"<p>El objetivo de este trabajo consiste en investigar al menos 4 microcontroladores de distintas marcas que puedan ser utilizados para la fabricaci\u00f3n de una lampara para dormir y hacer una tabla comparativa de:</p> <ul> <li>Perifericos </li> <li>Memoria </li> <li>Ecosistema </li> <li>Costos </li> <li>Arquitectura </li> <li>Velocidad de trabajo </li> </ul>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_1/#proyecto","title":"Proyecto","text":"<p>Lampara para dormir que cambia el color y potencia de la luz para ayudar a inducir el sue\u00f1o.</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_1/#tabla-comparativa","title":"Tabla comparativa","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_1/#ranking-mejor-a-peor","title":"Ranking (mejor a peor)","text":"<ol> <li>ATmega328P :Es f\u00e1cil de programar en Arduino IDE, barato, y debido a su gran comunidad ya hay ejemplos y gu\u00edas f\u00e1ciles que se pueden utilizar como referencia.</li> <li>PIC16F877A :Cuenta con una memoria EEPROM (memoria de solo lectura programable y borrable el\u00e9ctricamente), que permite guardar datos incluso al estar apagada, ecosistema menos amigable, requiere MPLAB X IDE y compilador XC8, no es tan f\u00e1cil de programar con en Arduino.</li> <li>STM32F103RG :Este micro es muy poderoso (32 bits, 72 MHz) y con muchos perif\u00e9ricos, es muy r\u00e1pido, con mucha memoria y muy profesional, pero por lo mismo es m\u00e1s complejo de programar, requiere m\u00e1s energ\u00eda y es m\u00e1s costoso.</li> <li>ESP32 :Aunque es s\u00faper potente (Wi-Fi, Bluetooth, doble n\u00facleo a 240 MHz), todas esas caracter\u00edsticas sobran para una l\u00e1mpara.Su precio es el m\u00e1s alto, y es relativamente m\u00e1s complejo de configurar en comparaci\u00f3n con los dem\u00e1s</li> </ol>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_2/","title":"Tarea 2","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_2/#objetivo","title":"Objetivo","text":"<p>Realizar las siguientes tareas usando codigos que ocupen logica y mascaras, no se pueden poner todas las combinaciones:</p> <ol> <li>Contador binario 4 bits:En cuentro leds debe mostrarse cad segundo la representacion binaria del 0 al 15.</li> <li>Barrido de leds:Correr un \u201c1\u201d por cuatro LEDs P0..P3 y regresar (0\u21921\u21922\u21923\u21922\u21921).</li> <li>Secuencia en c\u00f3digo Gray:Es una representaci\u00f3n binaria donde cada valor sucesivo difiere en un solo bit del valor anterior.</li> </ol>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_2/#contador-binario-de-4-bits","title":"Contador binario de 4 bits","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n\nint main() {\n    const uint LEDS[4] = {0, 1, 2, 3};\n\n    for (int i = 0; i &lt; 4; i++) {\n        gpio_init(LEDS[i]);\n        gpio_set_dir(LEDS[i], true);\n    }\n\n    while (true) {\n        for (int count = 0; count &lt; 16; count++) {\n            for (int i = 0; i &lt; 4; i++) {\n                if (count &amp; (1 &lt;&lt; i))\n                    sio_hw-&gt;gpio_set = (1u &lt;&lt; LEDS[i]);\n                else\n                    sio_hw-&gt;gpio_clr = (1u &lt;&lt; LEDS[i]);\n            }\n            sleep_ms(1000);\n        }\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_2/#barrido-de-leds","title":"Barrido de leds","text":"<pre><code>#include \"pico/stdlib.h\"\n\n#define NUM_LEDS 4\n#define DELAY_MS 150\n\nint main() {\n    const uint LED_PINS[NUM_LEDS] = {0, 1, 2, 3};\n\n    for (int i = 0; i &lt; NUM_LEDS; i++) {\n        gpio_init(LED_PINS[i]);\n        gpio_set_dir(LED_PINS[i], GPIO_OUT);\n    }\n\n    int current_led = 0;\n    int direction = 1;\n\n    while (true) {\n        gpio_put(LED_PINS[current_led], 1);\n        sleep_ms(DELAY_MS);\n        gpio_put(LED_PINS[current_led], 0);\n\n        current_led += direction;\n\n        if (current_led == 0 || current_led == NUM_LEDS - 1) {\n            direction *= -1;\n        }\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_2/#secuencia-en-codigo-gray","title":"Secuencia en c\u00f3digo Gray","text":"<pre><code>#include \"pico/stdlib.h\"\n#include &lt;stdint.h&gt;\n\n#define NUM_LEDS 4\n#define DELAY_MS 1000\n\nuint8_t binary_to_gray(uint8_t n) {\n    return n ^ (n &gt;&gt; 1);\n}\n\nint main() {\n    const uint LED_PINS[NUM_LEDS] = {0, 1, 2, 3};\n\n    for (int i = 0; i &lt; NUM_LEDS; i++) {\n        gpio_init(LED_PINS[i]);\n        gpio_set_dir(LED_PINS[i], GPIO_OUT);\n    }\n\n    uint8_t counter = 0;\n\n    while (true) {\n        uint8_t gray_value = binary_to_gray(counter);\n\n        for (int i = 0; i &lt; NUM_LEDS; i++) {\n            bool bit_value = (gray_value &gt;&gt; i) &amp; 1;\n            gpio_put(LED_PINS[i], bit_value);\n        }\n\n        sleep_ms(DELAY_MS);\n\n        counter = (counter + 1) % 16;\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_2/#diagrama-de-conexion","title":"Diagrama de conexi\u00f3n","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_3/","title":"Tarea 3","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_3/#objetivo","title":"Objetivo","text":"<p>Crear los siguientes c\u00f3digos usando l\u00f3gica y m\u00e1scaras (no se vale enumerar todas las combinaciones con if):</p> <p>Compuertas b\u00e1sicas AND / OR / XOR con 2 botones</p> <p>Qu\u00e9 debe hacer: Con dos botones A y B (pull-up; presionado=0) enciende tres LEDs que muestren en paralelo los resultados de AND, OR y XOR. En el video muestra las 4 combinaciones (00, 01, 10, 11).</p> <p>Selector c\u00edclico de 4 LEDs con avance/retroceso</p> <p>Qu\u00e9 debe hacer: Mant\u00e9n un \u00fanico LED encendido entre LED0..LED3. Un bot\u00f3n AVANZA (0\u21921\u21922\u21923\u21920) y otro RETROCEDE (0\u21923\u21922\u21921\u21920). Un push = un paso (antirrebote por flanco: si dejas presionado no repite). En el video demuestra en ambos sentidos.</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_3/#compuertas-andorxor","title":"Compuertas AND/OR/XOR","text":"<pre><code>#include \"pico/stdlib.h\"   \n\n\n#define BTN_A 4\n#define BTN_B 5\n#define LED_AND 0\n#define LED_OR  1\n#define LED_XOR 2\n\nint main() {\n    stdio_init_all();  \n\n    // Configurar botones como entrada con resistencia pull-up\n    gpio_init(BTN_A);\n    gpio_set_dir(BTN_A, false);   // false = input\n    gpio_pull_up(BTN_A);          // activa resistencia pull-up\n\n    gpio_init(BTN_B);\n    gpio_set_dir(BTN_B, false);   \n    gpio_pull_up(BTN_B);\n\n    // Configurar LEDs como salida\n    gpio_init(LED_AND);\n    gpio_set_dir(LED_AND, true);  // true = output\n\n    gpio_init(LED_OR);\n    gpio_set_dir(LED_OR, true);\n\n    gpio_init(LED_XOR);\n    gpio_set_dir(LED_XOR, true);\n\n\n    while (true) {\n\n        uint A = !gpio_get(BTN_A);  // lee bot\u00f3n A \n        uint B = !gpio_get(BTN_B);  // lee bot\u00f3n B\n\n        // l\u00f3gica con m\u00e1scaras\n        uint res_and = A &amp; B;   \n        uint res_or  = A | B;   \n        uint res_xor = A ^ B;   \n\n        // mandamos el resultado a los LEDs\n        gpio_put(LED_AND, res_and);\n        gpio_put(LED_OR,  res_or);\n        gpio_put(LED_XOR, res_xor);\n\n        sleep_ms(50); \n    }\n}\n</code></pre> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\nconst uint LED_PINS[] = {0, 1, 2, 3};\nconst int NUM_LEDS = sizeof(LED_PINS) / sizeof(LED_PINS[0]);\n\nconst uint LEFT_BUTTON_PIN = 4;\nconst uint RIGHT_BUTTON_PIN = 5;\n\nconst int DEBOUNCE_DELAY_MS = 100;\n\nvoid setup_gpio();\nvoid update_leds(int current_led_index);\n\nint main() {\n    stdio_init_all();\n    setup_gpio();\n\n    int current_led = 0;\n    update_leds(current_led);\n\n    while (true) {\n        if (!gpio_get(RIGHT_BUTTON_PIN)) {\n            sleep_ms(DEBOUNCE_DELAY_MS);\n            if (!gpio_get(RIGHT_BUTTON_PIN)) {\n                current_led++;\n                if (current_led &gt;= NUM_LEDS) {\n                    current_led = 0;\n                }\n                update_leds(current_led);\n                while (!gpio_get(RIGHT_BUTTON_PIN));\n            }\n        }\n\n        if (!gpio_get(LEFT_BUTTON_PIN)) {\n            sleep_ms(DEBOUNCE_DELAY_MS);\n            if (!gpio_get(LEFT_BUTTON_PIN)) {\n                current_led--;\n                if (current_led &lt; 0) {\n                    current_led = NUM_LEDS - 1;\n                }\n                update_leds(current_led);\n                while (!gpio_get(LEFT_BUTTON_PIN));\n            }\n        }\n    }\n    return 0;\n}\n\nvoid setup_gpio() {\n    for (int i = 0; i &lt; NUM_LEDS; i++) {\n        gpio_init(LED_PINS[i]);\n        gpio_set_dir(LED_PINS[i], GPIO_OUT);\n    }\n\n    gpio_init(LEFT_BUTTON_PIN);\n    gpio_set_dir(LEFT_BUTTON_PIN, GPIO_IN);\n    gpio_pull_up(LEFT_BUTTON_PIN);\n\n    gpio_init(RIGHT_BUTTON_PIN);\n    gpio_set_dir(RIGHT_BUTTON_PIN, GPIO_IN);\n    gpio_pull_up(RIGHT_BUTTON_PIN);\n}\n\nvoid update_leds(int current_led_index) {\n    for (int i = 0; i &lt; NUM_LEDS; i++) {\n        if (i == current_led_index) {\n            gpio_put(LED_PINS[i], 1);\n        } else {\n            gpio_put(LED_PINS[i], 0);\n        }\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_3/#diagrama-de-conexion","title":"Diagrama de conexi\u00f3n","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_4/","title":"Tarea 4","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_4/#objetivo","title":"Objetivo","text":"<p>Programar un mini-Pong con 5 LEDs en l\u00ednea y 2 botones usando interrupciones (ISR) para registrar el \u201cgolpe\u201d del jugador exactamente cuando la \u201cpelota\u201d (un LED encendido) llega al extremo de su lado.</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_4/#reglas-del-codigo","title":"Reglas del c\u00f3digo","text":"<ol> <li>Pelota: es un \u00fanico LED encendido que se mueve autom\u00e1ticamente de un extremo al otro (L1\u2192L5\u2192L1\u2026) a un ritmo fijo.</li> <li>Golpe con ISR:cada bot\u00f3n genera una interrupci\u00f3n.</li> </ol> <p>El BTN_L solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L1.</p> <p>El BTN_R solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L5.</p> <p>Si coincide, la pelota rebota: invierte su direcci\u00f3n.</p> <p>Si no coincide (la pelota no est\u00e1 en el \u00faltimo LED de ese lado), el bot\u00f3n se ignora.</p> <ol> <li> <p>Fallo y punto:si la pelota alcanza L1 y no hubo golpe v\u00e1lido del lado izquierdo en ese momento, anota el jugador derecho. An\u00e1logamente, si alcanza L5 sin golpe v\u00e1lido, anota el jugador izquierdo.</p> </li> <li> <p>Indicador de punto:al anotar, se parpadea el LED de punto 3 veces del jugador que meti\u00f3 el punto .</p> </li> <li> <p>Reinicio tras punto:despu\u00e9s del parpadeo, la pelota se reinicia en el centro (L3) y comienza a moverse hacia el jugador que meti\u00f3 el punto.</p> </li> <li> <p>Inicio del juego:al encender, la pelota inicia en L3 y no se mueve hasta que se presione un boton y debera moverse a la direccion opuesta del boton presionado.</p> </li> </ol>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_4/#codigo-pong","title":"C\u00f3digo PONG","text":"<pre><code>//Pong version final\n\n#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n#include \"hardware/watchdog.h\"\n\n#define NUM_LEDS 5\n#define DELAY_MS 400\n\nconst uint BTN1 = 5; // bot\u00f3n izquierdo\nconst uint BTN2 = 6; // bot\u00f3n derecho\nconst uint LED_PINS[NUM_LEDS] = {0, 1, 2, 3, 4};\nconst uint LEDG1 = 8; // LED indicador derecha\nconst uint LEDG2 = 7; // LED indicador izquierda\n\nvolatile bool REBOTE1 = false;\nvolatile bool REBOTE2 = false;\n\nvoid button_isr(uint gpio, uint32_t events)\n{\n    if (gpio == BTN1)\n        REBOTE1 = true;\n    else if (gpio == BTN2)\n        REBOTE2 = true;\n}\n\n// --- Funci\u00f3n para indicar un punto ---\nvoid score_point(uint led)\n{\n    for (int i = 0; i &lt; 3; i++)\n    {\n        gpio_put(led, 1);\n        sleep_ms(150);\n        gpio_put(led, 0);\n        sleep_ms(150);\n    }\n}\n\nint main()\n{\n    // Inicializar LEDs de victoria\n    gpio_init(LEDG1);\n    gpio_set_dir(LEDG1, true);\n    gpio_put(LEDG1, 0);\n    gpio_init(LEDG2);\n    gpio_set_dir(LEDG2, true);\n    gpio_put(LEDG2, 0);\n\n    // Inicializar botones\n    gpio_init(BTN1);\n    gpio_set_dir(BTN1, false);\n    gpio_pull_up(BTN1);\n    gpio_set_irq_enabled_with_callback(BTN1, GPIO_IRQ_EDGE_FALL, true, &amp;button_isr);\n\n    gpio_init(BTN2);\n    gpio_set_dir(BTN2, false);\n    gpio_pull_up(BTN2);\n    gpio_set_irq_enabled(BTN2, GPIO_IRQ_EDGE_FALL, true);\n\n    // Inicializar LEDs del juego\n    for (int i = 0; i &lt; NUM_LEDS; i++)\n    {\n        gpio_init(LED_PINS[i]);\n        gpio_set_dir(LED_PINS[i], true);\n    }\n\n    int current_led = NUM_LEDS / 2;\n    int direction = 0; // 0 = stopped, 1 = right, -1 = left\n    bool game_started = false;\n\n    // Show ball at center before game starts\n    gpio_put(LED_PINS[current_led], 1);\n\n    while (true)\n    {\n        if (!game_started)\n        {\n            if (REBOTE1)\n            {\n                direction = 1; // Move right\n                game_started = true;\n                REBOTE1 = false;\n                gpio_put(LED_PINS[current_led], 0); // Turn off center LED\n            }\n            else if (REBOTE2)\n            {\n                direction = -1; // Move left\n                game_started = true;\n                REBOTE2 = false;\n                gpio_put(LED_PINS[current_led], 0); // Turn off center LED\n            }\n            else\n            {\n                // Wait for button press to start\n                tight_loop_contents();\n                continue;\n            }\n        }\n\n        gpio_put(LED_PINS[current_led], 1);\n        sleep_ms(DELAY_MS);\n        gpio_put(LED_PINS[current_led], 0);\n\n        current_led += direction;\n\n        // PELOTA IZQUIERDA\n        if (current_led == -1)\n        {\n            if (REBOTE1)\n            {\n                direction = 1;\n                current_led = 0;\n                REBOTE1 = false;\n            }\n            else\n            {\n                // Jugador dos (derehca) scores\n                score_point(LEDG1);\n                current_led = NUM_LEDS / 2; // Resetea al centro\n                direction = 1;              // Move towards winner (right)\n            }\n        }\n\n        // PELOTA DERECHA\n        if (current_led == NUM_LEDS)\n        {\n            if (REBOTE2)\n            {\n                direction = -1;\n                current_led = NUM_LEDS - 1;\n                REBOTE2 = false;\n            }\n            else\n            {\n                // Player 1 (left) scores\n                score_point(LEDG2);\n                current_led = NUM_LEDS / 2; // Reset to center\n                direction = -1;             // Move towards winner (left)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_4/#diagrama-de-conexion","title":"Diagrama de conexi\u00f3n","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_4/#se-estan-respetando-los-limites-de-corriente-de-los-pines-de-la-pico-2","title":"\u00bfSe est\u00e1n respetando los l\u00edmites de corriente de los pines de la Pico 2?","text":"<p>\u00bfAcaso te hiciste esa pregunta al ver este trabajo?, pues yo tampoco pero gracias a Dios no quemamos ninguno de los pines, entonces hagamos el c\u00e1lculo de porque no cometimos la tonter\u00eda de quemarlos:</p> <p>Tenemos los siguientes componentes conectados a la Pico 2:</p> <ul> <li>7 Leds:todos con resistencias de 1K conectadas a GND.</li> <li>2 Push button:tenemos 2 Push buttons conectados igual a resistencias de 1K conectadas a GND.</li> </ul> <p>Para el c\u00e1lculo usamos la Ley de Ohm, que funciona de forma que la corriente es igual a (Voltaje del pin-Voltaje del Led)/Resistencia, los pines tienen un voltaje de salida de 3.3V y los leds est\u00e1ndar consumen 2V, por lo que:</p> <p>(3.3V-2V/1 Kilo Ohm)=1.3 mA</p> <p>Los botones con resistencia de 1 k\u03a9 en serie limitan la corriente cuando se presionan, por lo que los calculos nos dar\u00edan (Voltaje de pin/resistencia), lo que nos da:</p> <p>(3.3V/1 Kilo Ohm)=3.3 mA</p> <p>Los GPIO de la Pico 2 soportan hasta 12\u202fmA recomendados por pin, con m\u00e1ximo absoluto de 16\u202fmA, y la corriente total del chip recomienda 50\u202fmA en todos los pines juntos, por lo que se pude notar que se est\u00e1 dentro del l\u00edmite permitido.</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_5/","title":"Tarea 5","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_5/#ejercicio-1","title":"Ejercicio 1","text":"<p>Genera una onda cuadrada por toggle de un pin de salida en la ISR de ALARM0, con rearme acumulativo y periodo nominal definido por ti (p. ej., 100 \u00b5s\u20135 ms). Mide con osciloscopio:</p> <ol> <li>Periodo promedio y tolerancia.</li> <li>Jitter pico-a-pico y, si tu equipo lo permite, RMS.</li> <li>Describe la configuraci\u00f3n del osciloscopio (acoplamiento, escala de tiempo/voltaje, modo de medici\u00f3n). No cambiar la resoluci\u00f3n del timer (mantener modo \u00b5s).</li> </ol> <pre><code>// Blink con timer (SDK alto nivel): cambia BLINK_MS para ajustar\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n\n#define LED_PIN PICO_DEFAULT_LED_PIN\nstatic const int BLINK_MS = 250;  // &lt;-- ajusta tu periodo aqu\u00ed\n\nbool blink_cb(repeating_timer_t *t) {\n    static bool on = false;\n    gpio_put(LED_PIN, on = !on);\n    return true; // seguir repitiendo la alarma\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    repeating_timer_t timer;\n    // Programa una interrupci\u00f3n peri\u00f3dica cada BLINK_MS:\n    add_repeating_timer_ms(BLINK_MS, blink_cb, NULL, &amp;timer);\n\n    while (true) {\n        // El trabajo \"pesado\" deber\u00eda ir aqu\u00ed (no en la ISR).\n        tight_loop_contents();\n    }\n}\n</code></pre> <p></p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_5/#ejercicio-2","title":"Ejercicio 2","text":"<p>Genera una se\u00f1al por toggle en la ISR de ALARM0, primero en modo \u00b5s y luego en modo ciclos de clk_sys (mismo periodo nominal). En ambos casos:</p> <ol> <li>Usa rearme acumulativo.</li> <li>Mant\u00e9n el resto del c\u00f3digo id\u00e9ntico</li> <li>Con el osciloscopio, mide y registra para cada modo:periodo promedio y desviaci\u00f3n respecto al nominal, Jitter pico-a-pico y/o RMS, Compara resultados y discute el compromiso entre resoluci\u00f3n de tick y horizonte de programaci\u00f3n.</li> </ol> <pre><code>// Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       PICO_DEFAULT_LED_PIN\n#define ALARM_NUM     0  // usaremos la alarma 0\n\n// Calcula el n\u00famero de IRQ para esa alarma \n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 500000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre> <p></p> <p>La diferencia se dio porque en el segundo c\u00f3digo estoy trabajando directamente con los registros y las interrupciones, y ah\u00ed la precisi\u00f3n depende del tiempo que tarda el procesador en atender la interrupci\u00f3n y volver a programar el siguiente evento. Ese peque\u00f1o retraso se acumula y hace que la se\u00f1al no sea tan exacta. En cambio, el primer c\u00f3digo usa la funci\u00f3n del SDK, que ya est\u00e1 optimizada para corregir esos retardos y mantener el temporizador m\u00e1s estable, por eso en el osciloscopio obtuve una se\u00f1al m\u00e1s uniforme.</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_6/","title":"Tarea 6","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_6/#objetivo","title":"Objetivo","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_6/#ejercicio-1","title":"Ejercicio 1","text":"<ul> <li> <p>Programa cuatro alarmas / cuatro LEDs a distintas frecuencias.</p> </li> <li> <p>Configurar ALARM0..ALARM3 del timer de sistema en modo \u00b5s. Cada alarma controla un LED distinto con un periodo propio. </p> </li> </ul> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n// Definimos los pins\nconst uint LED_PINS[] = {0, 1, 2, 3};\nconst uint32_t PERIODS_US[] = {200000, 500000, 1000000, 2000000};\n#define NUM_LEDS 4\n\n// Programaic\u00f3n de la ISR universal para las 4 alarmas\nvoid timer_isr() {\n    uint64_t now = timer_hw-&gt;timerawl; //tiempo actual del sistema en microsegundos\n\n    for (int i = 0; i &lt; NUM_LEDS; i++) {\n        if (timer_hw-&gt;intr &amp; (1u &lt;&lt; i)) {   // Verificar interrupci\u00f3n de alarma i\n            gpio_xor_mask(1u &lt;&lt; LED_PINS[i]); // Con la mascara de XOR cambiamos el esta\n            timer_hw-&gt;alarm[i] = now + PERIODS_US[i]; // Reprogramar alarma, Se suma PERIODS_US[i] para que la pr\u00f3xima interrupci\u00f3n ocurra despues de ese tiempo\n            timer_hw-&gt;intr = (1u &lt;&lt; i);  // Con el 1 limpiamos la flag, con 0 no se hace nada\n        }\n    }\n}\n\nint main() {\n    stdio_init_all();\n\n    //Configuraciones de los pines de los leds\n\n\n    for (int i = 0; i &lt; NUM_LEDS; i++) {\n        gpio_init(LED_PINS[i]);\n        gpio_set_dir(LED_PINS[i], true);\n    }\n\n    //Configuraci\u00f3n de las interrupciones del timer\n    irq_set_exclusive_handler(TIMER0_IRQ_0, timer_isr);  \n    irq_set_enabled(TIMER0_IRQ_0, true);\n\n    // Alarmas\n    uint64_t now = timer_hw-&gt;timerawl;\n    for (int i = 0; i &lt; NUM_LEDS; i++) {\n        timer_hw-&gt;alarm[i] = now + PERIODS_US[i];//Con esto arranca las alarmas desde el momento en el que se inicializa\n    }\n\n    //Con esto habilitamos la funci\u00f3n de interrumpir, si no lo hacemos, las interrupciones \n    //no funcionan, por lo que activamos los 4 bits\n    timer_hw-&gt;inte = (1u &lt;&lt; 0) | (1u &lt;&lt; 1) | (1u &lt;&lt; 2) | (1u &lt;&lt; 3);\n\n    //loop de repetici\u00f3n (1) significa que se mantenga repiti\u00e9ndose\n    while (1) {\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_6/#ejercicio-2","title":"Ejercicio 2","text":"<p>Modificar el pong, para tener dos botones adicionales, que suban y bajen la velocidad del juego sin delay.</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define NUM_LEDS 5\n#define DELAY_MIN 100\n#define DELAY_MAX 1000\n#define DELAY_STEP 100\n\nconst uint BTN1 = 5;     // bot\u00f3n izquierdo\nconst uint BTN2 = 6;     // bot\u00f3n derecho\nconst uint BTN_UP = 16;   // subir velocidad\nconst uint BTN_DOWN = 17;// bajar velocidad\nconst uint LED_PINS[NUM_LEDS] = {0, 1, 2, 3, 4};\nconst uint LEDG1 = 8;    // LED indicador derecha\nconst uint LEDG2 = 7;    // LED indicador izquierda\n\nvolatile bool REBOTE1 = false;\nvolatile bool REBOTE2 = false;\nvolatile bool SPEED_UP = false;\nvolatile bool SPEED_DOWN = false;\n\nvoid button_isr(uint gpio, uint32_t events) {\n    if (gpio == BTN1) REBOTE1 = true;\n    else if (gpio == BTN2) REBOTE2 = true;\n    else if (gpio == BTN_UP) SPEED_UP = true;\n    else if (gpio == BTN_DOWN) SPEED_DOWN = true;\n}\n\nvoid score_point(uint led) {\n    for (int i = 0; i &lt; 3; i++) {\n        gpio_put(led, 1);\n        sleep_ms(150);\n        gpio_put(led, 0);\n        sleep_ms(150);\n    }\n}\n\nint main() {\n    // LEDs de victoria\n    gpio_init(LEDG1); gpio_set_dir(LEDG1, true);\n    gpio_init(LEDG2); gpio_set_dir(LEDG2, true);\n\n    // Botones\n    gpio_init(BTN1); gpio_set_dir(BTN1, false); gpio_pull_up(BTN1);\n    gpio_set_irq_enabled_with_callback(BTN1, GPIO_IRQ_EDGE_FALL, true, &amp;button_isr);\n\n    gpio_init(BTN2); gpio_set_dir(BTN2, false); gpio_pull_up(BTN2);\n    gpio_set_irq_enabled(BTN2, GPIO_IRQ_EDGE_FALL, true);\n\n    gpio_init(BTN_UP); gpio_set_dir(BTN_UP, false); gpio_pull_up(BTN_UP);\n    gpio_set_irq_enabled(BTN_UP, GPIO_IRQ_EDGE_FALL, true);\n\n    gpio_init(BTN_DOWN); gpio_set_dir(BTN_DOWN, false); gpio_pull_up(BTN_DOWN);\n    gpio_set_irq_enabled(BTN_DOWN, GPIO_IRQ_EDGE_FALL, true);\n\n    // LEDs del juego\n    for (int i = 0; i &lt; NUM_LEDS; i++) {\n        gpio_init(LED_PINS[i]);\n        gpio_set_dir(LED_PINS[i], true);\n    }\n\n    int current_led = NUM_LEDS / 2;\n    int direction = 0;\n    bool game_started = false;\n    int delay_ms = 400; // velocidad inicial\n\n    gpio_put(LED_PINS[current_led], 1);\n\n    while (true) {\n        // Ajustar velocidad (nota: se eval\u00faa **una vez por ciclo**)\n        if (SPEED_UP) {\n            if (delay_ms &gt; DELAY_MIN) delay_ms -= DELAY_STEP;\n            SPEED_UP = false;\n        }\n        if (SPEED_DOWN) {\n            if (delay_ms &lt; DELAY_MAX) delay_ms += DELAY_STEP;\n            SPEED_DOWN = false;\n        }\n\n        // Inicio del juego\n        if (!game_started) {\n            if (REBOTE1) { direction = 1; game_started = true; REBOTE1 = false; gpio_put(LED_PINS[current_led], 0);}\n            else if (REBOTE2) { direction = -1; game_started = true; REBOTE2 = false; gpio_put(LED_PINS[current_led], 0);}\n            else continue;\n        }\n\n        gpio_put(LED_PINS[current_led], 1);\n        sleep_ms(delay_ms);  // &lt;&lt;&lt;&lt;&lt;&lt; el delay depende del bot\u00f3n\n        gpio_put(LED_PINS[current_led], 0);\n\n        current_led += direction;\n\n        if (current_led == -1) {\n            if (REBOTE1) { direction = 1; current_led = 0; REBOTE1 = false; }\n            else { score_point(LEDG1); current_led = NUM_LEDS/2; direction = 1; }\n        }\n        if (current_led == NUM_LEDS) {\n            if (REBOTE2) { direction = -1; current_led = NUM_LEDS - 1; REBOTE2 = false; }\n            else { score_point(LEDG2); current_led = NUM_LEDS/2; direction = -1; }\n        }\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_6/#diagrama-de-conexion","title":"Diagrama de conexi\u00f3n","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_7/","title":"Tarea 7","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_7/#tarea-71","title":"Tarea 7.1","text":"<p>Implementar un circuito con un motor DC controlado mediante PWM variando el duty cycle.</p> <p>Usar 2 botones para seleccionar entre 3 velocidades predefinidas (baja, media y alta).</p> <p>Documentar:</p> <ul> <li> <p>Valores de duty usados, con el porque.</p> </li> <li> <p>Circuito</p> </li> <li> <p>Codigo</p> </li> </ul> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define LED_PIN 1\nconst uint BTN1 = 2; \nconst uint BTN2 = 3; \n#define F_PWM_HZ 2000\n#define TOP 1022\n\nint main() {\n    stdio_init_all();\n\n    // Inicializar botones con pull-up\n    gpio_init(BTN1); gpio_set_dir(BTN1, GPIO_IN); gpio_pull_up(BTN1);\n    gpio_init(BTN2); gpio_set_dir(BTN2, GPIO_IN); gpio_pull_up(BTN2);\n\n    // Configurar LED como PWM\n    gpio_set_function(LED_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(LED_PIN);\n    uint chan  = pwm_gpio_to_channel(LED_PIN);\n\n    float f_clk = 125000000.0f;\n    float div = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n    pwm_set_chan_level(slice, chan, 0); // inicia apagado\n    pwm_set_enabled(slice, true);\n\n    int level = 622;  // nivel inicial\n\n    // Con esto podemos hacer que solo se tenga que presionar el boton 1 vez\n    bool btn1_presionado = false;\n    bool btn2_presionado = false;\n\n    while (true) {\n        // Leer botones\n        bool b1 = gpio_get(BTN1) == 0;\n        bool b2 = gpio_get(BTN2) == 0;\n\n        // El boton 1 disminuye el nivel 200\n        if (b1 &amp;&amp; !btn1_presionado) {\n            level -= 200;\n            if (level &lt; 0) level = 0; // limite m\u00ednimo\n            btn1_presionado = true;\n        } else if (!b1) {\n            btn1_presionado = false;\n        }\n\n        // BTN2 \u2192 aumentar nivel 200\n        if (b2 &amp;&amp; !btn2_presionado) {// Si el boton esta presionado y b2 es 1\n            level += 200;\n            if (level &gt; TOP) level = TOP; // limite en el TOP\n            btn2_presionado = true;\n        } else if (!b2) {\n            btn2_presionado = false;//Con esto mantenemos registro de si estan presionados o no, para usar como referencia\n        }\n\n        // Aplicar PWM\n        pwm_set_chan_level(slice, chan, level);\n\n\n    }\n}\n</code></pre> <p></p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_7/#tarea-72","title":"Tarea 7.2","text":"<p>Programar un buzzer piezoel\u00e9ctrico para reproducir una melod\u00eda reconocible.</p> <p>Variar la frecuencia del PWM para las notas, manteniendo el duty en 50 %.</p> <p>Cada nota debe incluir su frecuencia y duraci\u00f3n en el c\u00f3digo.</p> <p>Documentar:</p> <ul> <li> <p>Tabla con notas, frecuencias y duraci\u00f3n usadas.</p> </li> <li> <p>Evidencia en audio o video de la melod\u00eda funcionando.</p> </li> </ul> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define BUZZER_PIN 5\n#define TOP 2048\n\n// Notas\n#define FAs 740.0f\n#define RE  587.0f  \n#define SI  494.0f\n#define MI  659.0f\n#define SOLs 831.0f\n#define LA  880.0f\n#define DOs 988.0f\n\n// Duraciones\n#define CORCHEA 214\n#define SILENCIO 214  // Los espacios son silencios de 214ms\n\nvoid tocar_nota(uint slice, uint chan, float frecuencia, int duracion) {\n    if (frecuencia &gt; 1.0f) {\n        float f_clk = 150000000.0f;\n        float div = f_clk / (frecuencia * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, TOP / 2);\n        sleep_ms(duracion);\n        pwm_set_chan_level(slice, chan, 0);\n    }\n    sleep_ms(30); // Peque\u00f1a pausa entre notas\n}\n\nvoid tocar_silencio(int duracion) {\n    sleep_ms(duracion);\n}\n\nvoid tocar_melodia(uint slice, uint chan) {\n\n\n    // MI MI MI\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, MI, 600);\n\n    tocar_silencio(150);\n\n    // MI MI MI\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, MI, 600);\n\n    tocar_silencio(150);\n\n    // MI SOLs DOs RE MI\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, SOLs, 300);\n    tocar_nota(slice, chan, DOs, 300);\n    tocar_nota(slice, chan, RE, 300);\n    tocar_nota(slice, chan, MI, 600);\n\n    tocar_silencio(300);\n\n    // RE RE RE RE RE MI RE\n    tocar_nota(slice, chan, RE, 300);\n    tocar_nota(slice, chan, RE, 300);\n    tocar_nota(slice, chan, RE, 300);\n    tocar_nota(slice, chan, RE, 300);\n    tocar_nota(slice, chan, RE, 300);\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, RE, 600);\n\n    tocar_silencio(300);\n\n    // MI MI MI MI MI SOLs RE\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, MI, 300);\n    tocar_nota(slice, chan, SOLs, 300);\n    tocar_nota(slice, chan, RE, 600);\n\n    tocar_silencio(600); // Pausa larga antes de repetir\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(BUZZER_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(BUZZER_PIN);\n    uint chan  = pwm_gpio_to_channel(BUZZER_PIN);\n\n    pwm_set_wrap(slice, TOP);\n    pwm_set_chan_level(slice, chan, TOP / 2);\n    pwm_set_enabled(slice, true);\n\n    while (true) {\n        tocar_melodia(slice, chan);\n        sleep_ms(2000); // Pausa larga antes de repetir\n    }\n}\n</code></pre> <p></p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_7/#tarea-73","title":"Tarea 7.3","text":"<p>Generar una se\u00f1al sinusoidal aproximada de 60 Hz variando el duty cycle del PWM seg\u00fan una funci\u00f3n seno.</p> <p>Construir un filtro RC pasabajos b\u00e1sico y verificar la se\u00f1al en el osciloscopio:</p> <p>Documentar:</p> <ul> <li>Capturas de osciloscopio Antes del filtro (PWM) y Despu\u00e9s del filtro.</li> </ul> <p>El filtro RC se dise\u00f1a para dejar pasar se\u00f1ales de 60 Hz y eliminar las componentes de alta frecuencia que provienen del PWM.</p> <p>La frecuencia de corte (fcf_cfc\u200b) es el punto donde el filtro empieza a atenuar las se\u00f1ales. Matem\u00e1ticamente:</p> <p>En este caso, queremos que fc sea un poco mayor que 60 Hz para que nuestra se\u00f1al sinusoidal de 60 Hz no sea atenuada.</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_7/#senal-pre-filtro","title":"Se\u00f1al pre filtro","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_7/#senal-filtrada","title":"Se\u00f1al filtrada","text":"<p><pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;math.h&gt;\n\n#define PWM_PIN 18\n#define F_PWM_HZ 2000   // Frecuencia PWM alta para filtrar luego\n#define TOP 1023        // Resoluci\u00f3n 10 bits\n#define F_SIGNAL 60     // Frecuencia de la se\u00f1al sinusoidal (Hz)\n#define SAMPLES 100     // Cantidad de pasos por ciclo sinusoidal\n#define PI 3.14159265\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(PWM_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(PWM_PIN);\n    uint chan  = pwm_gpio_to_channel(PWM_PIN);\n\n    // Calcular divisor para la frecuencia PWM\n    float f_clk = 125000000.0f; // 125 MHz\n    float div = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n    pwm_set_chan_level(slice, chan, 0);\n    pwm_set_enabled(slice, true);\n\n    int sample_index = 0;\n\n    while (true) {\n        // Duty cycle siguiendo un seno: 0..TOP\n        float angle = 2 * PI * sample_index / SAMPLES;\n        int duty = (int)((TOP / 2.0) + (TOP / 2.0) * sin(angle));\n\n        pwm_set_chan_level(slice, chan, duty);\n\n        sample_index = (sample_index + 1) % SAMPLES;\n\n        // Espera entre muestras para que la se\u00f1al tenga 60 Hz\n        sleep_us(1000000 / (F_SIGNAL * SAMPLES));\n    }\n\n    return 0;\n}\n</code></pre> </p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_8/","title":"Tarea 8","text":"<p>1 - Por medio de comunicaci\u00f3n entre dos Pico 2 , lograr accionar leds con botones. 2 - Por medio de la consola lograr prender leds conectados a las Pico 2. 3 - Elaborar un Hanshake.</p>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_8/#codigo-1-echo","title":"C\u00f3digo 1 (echo)","text":"<pre><code>#include \"pico/stdlib.h\"\n#include &lt;stdio.h&gt;\n\n#define UART_ID uart1\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n\n\n\nint main() {\n    stdio_init_all();\n\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n\n    sleep_ms(2000); // tiempo para enumeraci\u00f3n USB\n\n    while (getchar_timeout_us(0) != PICO_ERROR_TIMEOUT) {\n    // solo leer y descartar cualquier car\u00e1cter residual\n}\n\n    printf(\"\\n[Pico USB] Conexi\u00f3n lista. Escribe algo y Enter.\\n\");\n\n    while (true) {\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            printf(\"Eco: %c\\n\", (char)ch);\n            uart_putc(UART_ID, (char)ch); \n        }\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_8/#codigo-2-envia-y-recibe","title":"C\u00f3digo 2 (envia y recibe)","text":"<pre><code>#include \"pico/stdlib.h\"\n#include &lt;stdio.h&gt;\n\n#define UART_ID uart1\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n\n\n\nint main() {\n    stdio_init_all();\n\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n\n    sleep_ms(2000); // tiempo para enumeraci\u00f3n USB\n\n    while (getchar_timeout_us(0) != PICO_ERROR_TIMEOUT) {\n    // solo leer y descartar cualquier car\u00e1cter residual\n}\n\n    printf(\"\\n[Pico USB] Conexi\u00f3n lista. Escribe algo y Enter.\\n\");\n\n    while (true) {\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            printf(\"Eco: %c\\n\", (char)ch);\n            uart_putc(UART_ID, (char)ch); \n        }\n\n        if (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            printf(\"%c\", c);\n\n        }\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_8/#prendido-de-leds-por-medio-de-boton-fisico","title":"Prendido de leds por medio de boton f\u00edsico","text":"<pre><code>#include \"pico/stdlib.h\"\n#include &lt;stdio.h&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define BTN 3\n#define LED 2\n\n\n\nint main() {\n\n\n    stdio_init_all();\n\n\n    gpio_init(LED);\n    gpio_set_dir(LED, true);\n\n    gpio_init(BTN);\n    gpio_set_dir(BTN, false);\n    gpio_pull_up(BTN);\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n\n    sleep_ms(2000); // tiempo para enumeraci\u00f3n USB\n\n    while (getchar_timeout_us(0) != PICO_ERROR_TIMEOUT) {\n    // solo leer y descartar cualquier car\u00e1cter residual\n}\n\n    printf(\"\\n[Pico USB] Conexi\u00f3n lista. Escribe algo y Enter.\\n\");\n\n    while (true) {\n\n        if (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            printf(\"%c\", c);\n\n            if (c == '1') {\n                gpio_put(LED, 1);  \n                printf(\"LED encendido!\\n\");\n            } \n\n            else {\n                gpio_put(LED, 0);  \n\n            }\n         }\n\n        bool pressed = !gpio_get(BTN);  \n        if (pressed) {\n            printf(\"Bot\u00f3n presionado!\\n\");\n            uart_putc(UART_ID, '1');\n            sleep_ms(300); \n\n\n        }\n         sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_8/#prendido-de-leds-por-medio-de-consola","title":"Prendido de leds por medio de consola","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nint main() {\n    stdio_init_all(); // Inicializa USB serial\n    sleep_ms(2000);\n\n    printf(\"\\n[Pico listo] Comunicaci\u00f3n UART iniciando...\\n\");\n\n    // Inicializa UART antes de asignar pines\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    // Configuraci\u00f3n del LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    string mensaje_usb = \"\";\n    string mensaje_uart = \"\";\n\n    while (true) {\n        //Escritura mensaje\n        int ch = getchar_timeout_us(0); // no bloqueante\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!mensaje_usb.empty()) {\n                    uart_puts(UART_ID, (mensaje_usb + \"\\n\").c_str());\n                    printf(\"Mensaje enviado: %s\\n\", mensaje_usb.c_str());\n                    mensaje_usb = \"\";\n                }\n            } else {\n                mensaje_usb += (char)ch;\n            }\n        }\n\n        //Lectura en UART\n        while (uart_is_readable(UART_ID)) {\n            char ch_uart = uart_getc(UART_ID);\n\n            if (ch_uart == '\\n' || ch_uart == '\\r') {\n                if (!mensaje_uart.empty()) {\n                    printf(\"Mensaje recibido: %s\\n\", mensaje_uart.c_str());\n\n                    // Comparar informaci\u00f3n\n                    if (mensaje_uart == \"on\" || mensaje_uart == \"ON\") {\n                        gpio_put(LED_PIN, 1);\n                        printf(\"LED encendido\\n\");\n                    } else if (mensaje_uart == \"off\" || mensaje_uart == \"OFF\") {\n                        gpio_put(LED_PIN, 0);\n                        printf(\"LED apagado\\n\");\n                    } else {\n                        printf(\"Comando desconocido.\\n\");\n                    }\n\n                    mensaje_uart = \"\";\n                }\n            } else {\n                mensaje_uart += ch_uart;\n            }\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_8/#handshake","title":"Handshake","text":""},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_8/#codigo-maestro","title":"C\u00f3digo maestro","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nint main() {\n    stdio_init_all();\n    sleep_ms(2000);\n\n    printf(\"\\n[Pico A listo] Escribe 'conectar' para iniciar handshake.\\n\");\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    string usb_msg = \"\";\n    string uart_msg = \"\";\n    bool conectado = false;\n\n    while (true) {\n        // Leer comandos desde USB\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!usb_msg.empty()) {\n                    uart_puts(UART_ID, (usb_msg + \"\\n\").c_str());\n                    printf(\"[Enviado por UART]: %s\\n\", usb_msg.c_str());\n                    usb_msg = \"\";\n                }\n            } else usb_msg += (char)ch;\n        }\n\n        // Leer mensajes por UART\n        while (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            if (c == '\\n' || c == '\\r') {\n                if (!uart_msg.empty()) {\n                    printf(\"[Recibido]: %s\\n\", uart_msg.c_str());\n\n                    if (!conectado) {\n                        if (uart_msg == \"ok\") {\n                            printf(\"Pico B respondi\u00f3 OK.\\n\");\n                        } else if (uart_msg == \"conectado\") {\n                            printf(\"Conexi\u00f3n establecida \\n\");\n                            conectado = true;\n                        } else {\n                            printf(\"[Error] Mensaje inesperado durante handshake.\\n\");\n                        }\n                    } else {\n                        if (uart_msg == \"on\" || uart_msg == \"ON\") {\n                            gpio_put(LED_PIN, 1);\n                            printf(\"[LED] Encendido (por comando remoto)\\n\");\n                        } else if (uart_msg == \"off\" || uart_msg == \"OFF\") {\n                            gpio_put(LED_PIN, 0);\n                            printf(\"[LED] Apagado (por comando remoto)\\n\");\n                        } else {\n                            printf(\"Error: Comando desconocido tras conexi\u00f3n.\\n\");\n                        }\n                    }\n                    uart_msg = \"\";\n                }\n            } else uart_msg += c;\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_8/#codigo-esclavo","title":"C\u00f3digo esclavo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nint main() {\n    stdio_init_all();\n    sleep_ms(2000);\n\n    printf(\"\\nPico B listo, Esperando handshake desde el otro dispositivo...\\n\");\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n    uart_set_fifo_enabled(UART_ID, true);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    string uart_msg = \"\";\n    string usb_msg = \"\";\n    bool conectado = false;\n\n    while (true) {\n        // Leer mensajes entrantes por UART\n        while (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            if (c == '\\n' || c == '\\r') {\n                if (!uart_msg.empty()) {\n                    printf(\"Recibido: %s\\n\", uart_msg.c_str());\n\n                    if (!conectado) {\n                        if (uart_msg == \"conectar\") {\n                            uart_puts(UART_ID, \"ok\\n\");\n                            sleep_ms(300);\n                            uart_puts(UART_ID, \"conectado\\n\");\n                            conectado = true;\n                            printf(\"Conexi\u00f3n establecida\\n\");\n                        } else {\n                            uart_puts(UART_ID, \"error\\n\");\n                            printf(\"Error, mensaje inesperado durante handshake.\\n\");\n                        }\n                    } else {\n                        if (uart_msg == \"on\" || uart_msg == \"ON\") {\n                            gpio_put(LED_PIN, 1);\n                            printf(\"LED encendido\\n\");\n                        } else if (uart_msg == \"off\" || uart_msg == \"OFF\") {\n                            gpio_put(LED_PIN, 0);\n                            printf(\"LED apagado\\n\");\n                        } else {\n                            printf(\"[Error] Comando desconocido tras conexi\u00f3n.\\n\");\n                        }\n                    }\n                    uart_msg = \"\";\n                }\n            } else uart_msg += c;\n        }\n\n\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            if (ch == '\\n' || ch == '\\r') {\n                if (!usb_msg.empty()) {\n                    uart_puts(UART_ID, (usb_msg + \"\\n\").c_str());\n                    printf(\"[Enviado por UART]: %s\\n\", usb_msg.c_str());\n                    usb_msg = \"\";\n                }\n            } else usb_msg += (char)ch;\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"%F0%9F%92%BDSistemas_Embebidos/Tarea_8/#recomendaciones-importantes","title":"Recomendaciones importantes","text":"<p>En el cmake agergar:</p> <p>target_link_libraries(t\u00edtulo de tu documento         pico_stdlib         hardware_uart//Esto es importante agregar         ) Y mantener esto as\u00ed:</p> <p>pico_enable_stdio_uart(Examen_2 0) pico_enable_stdio_usb(Examen_2 1)</p>"}]}